package secure_data_warehouse;

import java.util.ArrayList;
//данный класс предназначен для хранения списка ответов теста
public class TestAnswersList2 {

    //список ответов
    //сделаем список ответов приватным и дадим доступ только через геттер, без сеттера, так как нам надо обеспечить
    //безопасность данных списка от любых изменений со стороны.
    private static ArrayList<String> answersList = new ArrayList<>();

    public static ArrayList<String> getAnswersList() {
        return answersList;
    }

    static
    {   //1) ООП
        answersList.add(" ООП - методология программирования, основанная на представлении программного продукта\n" +
                        " в виде совокупности объектов, каждый из которых является экземпляром конкретного класса.\n" +
                        " ООП использует в качестве базовых элементов взаимодействие объектов."); //ответ 1
        answersList.add(" Объект - именнованная модель реальной сущности, обладающая конкретными значениями свойств \n" +
                        " и проявляющая свое поведение, обладающий именем набор данных (полей и свойств объекта), \n" +
                        " физически находящихся в памяти компьютера, и методов, имеющих доступ к ним.\n" +
                        " Объект -конкретный экземпляр класса."); //ответ 2
        answersList.add(" Принято считать, что объектно-ориентированное программирование строится на 4 основных\n" +
                        " принципах (раньше их было всего 3). Эти принципы:\n" +
                        " (Абстракция)\n" +
                        " Инкапсуляция\n" +
                        " Наследование\n" +
                        " Полиморфизм"); //ответ 3
        answersList.add(" Наследование это процесс благодаря которому один объект может приобрести свойства\n" +
                        " другого объекта (наследование всех свойств одного объекта другим) и добавлять черты \n" +
                        " характерны только для него самого !\n" +
                        " class Dog extends Animal\n{...}\n" +
                        " Суперкласс -> Подкласс\n" +
                        " Родительский -> Дочерний"); //ответ 4
        answersList.add(" Полиморфизм (polymorphism) (от греческого polymorphos) - это свойство, которое позволяет\n" +
                        " одно и то же имя использовать для решения двух или более схожих, но технически разных задач.\n" +
                        " Целью полиморфизма, применительно к объектно-ориентированному программированию, является\n" +
                        " использование одного имени для задания общих для класса действий. Выполнение каждого\n" +
                        " конкретного действия будет определяться типом данных.\n" +
                        " В более общем смысле, концепцией полиморфизма является идея 'один интерфейс, множество методов'.\n" +
                        " Это означает, что можно создать общий интерфейс для группы близких по смыслу действий."); //ответ 5
        answersList.add(" Инкапсуляция (encapsulation) - это сокрытие реализации класса и отделение его внутреннего\n" +
                        " представления от внешнего (интерфейса) это свойство которое позволяет закрыть доступ к полям\n" +
                        " и методам класса другим классам и предоставлять им доступ только через интерфейс(метод)\n" +
                        " При использовании объектно-ориентированного подхода не принято применять прямой доступ\n" +
                        " к свойствам какого-либо класса из методов других классов. Для доступа к свойствам класса\n" +
                        " принято задействовать специальные методы этого класса для получения и изменения его свойств."); //ответ 6
        answersList.add(" Абстракция - это выделение общих характеристик объекта,исключая набор незначительных.\n" +
                        " С помощью принципа абстракции данных, данные преобразуются в объекты. Данные обрабатываются\n" +
                        " в виде цепочки сообщений между отдельными объектами. Все объекты проявляют свои уникальные\n" +
                        " признаки поведения. Огромный плюс абстракции в том, что она отделяет реализацию объектов\n" +
                        " от их деталей, что в свою очередь позволяет управлять функциями высокого уровня через функции\n" +
                        " низкого уровня."); //ответ 7
        answersList.add(" Они представляют реальные объекты в жизни, например, Машина, Джип, Счет в банке и тд...\n" +
                        " Инкапсуляция, наследование и полиморфизм делает его еще мощнее."); //ответ 8
        answersList.add(" Основные преимущества:\n" +
                        " 1) повторное использование кода(наследование);\n" +
                        " 2) реальное отображение предметной области. Объекты соответствуют реальному миру."); //ответ 9
        answersList.add(" \"является\"- наследование\n" +
                        " \"имеет\"- композиция\n" +
                        " В качестве примера предположим что у нас есть классы Строение, Дом и Ванная комната.\n" +
                        " Так вот Дом является строением, что нельзя сказать про Ванну, которая не является домом.\n" +
                        " А вот Дом имеет\\включает в себя Ванну. Если вы хотите использовать повторно код,\n" +
                        " то не обязательно использовать наследование. Если нет отношения, то лучше тогда\n" +
                        " использовать композицию для повторного использования кода. Не используйте наследование\n" +
                        " для получение полиморфизма, если нет ключевой зависимости \"является\".\n" +
                        " Используйте интерфейсы для полиморфизма. Из спецификации можно узнать, что\n" +
                        " 1) Ассоциация обозначает связь между объектами.\n" +
                        " 2) Агрегация и композиция это частные случаи ассоциации.\n" +
                        " Агрегация предполагает, что объекты связаны &nbsp;взаимоотношением \"part-of\" (часть).\n" +
                        " Композиция &nbsp;более строгий вариант агрегации. Дополнительно к требованию part-of\n" +
                        " накладывается условие, что \"часть\" не может одновременно принадлежать разным \"хозяевам\",\n" +
                        " и заканчивает своё существование вместе с владельцем.\n" +
                        " Например:\n" +
                        " мотоцикл -> cумка с багажём - ассоциация. Отношение \"имеет\".\n" +
                        " мотоцикл -> колесо - композиция.\n группа по интересам -> человек - агрегация.\n" +
                        " человек часть группы, но может принадлежать нескольким разным группам."); //ответ 10
        answersList.add(" Полиморфизм означает способность &nbsp;переменно данного типа, которая ссылается\n" +
                        " на объекты разных типов, при этом вызывается метод, характерный для конкретного\n" +
                        " типа ссылки на объект.\n В чем преимущество полиморфизма? Он позволяет добавлять\n" +
                        " новые классы производных объектов, не нарушая при этом код вызова. Также использование\n" +
                        " полиморфизма называют динамическим связыванием объектов.\n" +
                        " Рассмотрим пример полиморфизма:\n Имеются классы: Фигура, круг и треугольник.\n" +
                        " Круг и треугольник наследуется от фигуры соответственно. Каждый класс имеет метод \n" +
                        " 'рисовать'. В круге и треугольнике этот метод переопределен.\n" +
                        " Так вот, создаем объект с типом 'Фигура' и присваиваем ей ссылку на объект типа 'Круг'\n" +
                        " и вызываем на этом объекте метод 'рисовать'. В итоге вызывается метод класса\n" +
                        " 'Круг' а не класса 'Фигура' как ожидалось.\n\n " +
                        " Фигура ф = new Круг();\n" +
                        " Ф.рисовать();\n\n" +
                        " Также вместо класса родителя 'Фигура' к примеру можно использовать интерфейс 'Фигура',\n" +
                        " определив там метод рисовать. Этот интерфейс мы имплементируем в классах 'Круг' 'Треугольник'\n" +
                        " Далее на интерфейсе создаем&nbsp;объект и присваиваем ему ссылку на объект \n" +
                        " какого-то из реализующих этот интерфейс классов.\n" +
                        " Это удобно например если у нас есть некий метод:\n\n" +
                        " public void drawShape(Фигура ф){\n ф.рисовать();\n" +
                        " }\n\n" +
                        " Обратите внимание что в метод мы передаем параметр\n" +
                        " с типом интерфейса, т.е. мы не знаем какой именно тип объекта будем,\n" +
                        " но реализация будет таже. Далее мы можем просто создать еще класс, к примеру\n" +
                        ", имплементировать и имплементировать интерфейс 'Фигура' и просто передать экземпляр\n" +
                        " класса в метод, ничего не меняя в реализации и вызове." +
                        " Наследование это включение поведения(методы) и состояния(поля) базового класса\n" +
                        " в производный от него. В результате этого мы избегаем дублирования кода и процесс\n" +
                        " исправления ошибок в коде также упрощается." +
                        " В джава есть два вида наследования:\n" +
                        " 1) наследование классов. Каждый наследник может иметь толко одного родителя.\n" +
                        " 2) наследование &nbsp;интерфейсов. Интерфейс может иметь сколько угодно родителей.\n" +
                        " Некоторые тонкие ньюансы по поводу наследования интрефейсов и классов.\n" +
                        " Мы имеем два интерфейса с одинаковыми по имени полями. Имплементируем эти интерфейсы\n" +
                        " на каком-то классе. Как нам вызвать поля этих интерфейсов? У нас неоднозначность." +
                        " Необходимо объект класса привести к нужному интерфейсу.\n\n" +
                        " Класс к = new Класс();\n" +
                        " ((Интефейс1) к).поле;\n\n" +
                        " Хорошо, что будет если мы имеем метод с одинаковой сигнатурой в интерфейсах\n" +
                        " и реализуем эти интерфейсы на классе. Как нам в классе реализовать два метода\n" +
                        " с одинаковой сигнатурой???\n" +
                        " Ответ: никак, мы просто реализовываем один общий метод в классе.\n" +
                        " Это является недостатком, так как нам может потребоваться разная реализация.\n\n" +
                        " И третий случай: У нас есть класс и интерфейс с одинаковым по сигнатуре методом.\n" +
                        " Мы наследуемся от этого класса и имплементируем этот интерфейс. Что нам нужно делать?\n" +
                        " ведь необходимо реализовать метод интерфейса по всем правилам.\n" +
                        " И вот тут интересно, компилятор не выдает ошибок, так как метод уже у нас реализован\n" +
                        " в классе родителе."); //ответ 11

        //2) JAVA CORE
        answersList.add(" JRE кратко - для работы. Java Runtime Environment (сокр. JRE) - минимальная реализация\n" +
                        " виртуальной машины, необходимая для исполнения Java-приложений, без компилятора и других\n" +
                        " средств разработки. Состоит из виртуальной машины - Java Virtual Machine и библиотеки\n" +
                        " Java-классов.\n\n" +
                        " JDK кратко - для программирования. Java Development Kit (сокращенно JDK) - бесплатно\n" +
                        " распространяемый компанией Oracle Corporation (ранее Sun Microsystems) комплект\n" +
                        " разработчика приложений на языке Java, включающий в себя компилятор Java (javac),\n" +
                        " стандартные библиотеки классов Java, примеры, документацию, различные утилиты\n" +
                        " и исполнительную систему Java (JRE).\n Java Virtual Machine (сокращенно Java VM, JVM)\n" +
                        " - виртуальная машина Java - основная часть исполняющей системы Java, так называемой\n" +
                        " Java Runtime Environment (JRE). Виртуальная машина Java интерпретирует Байт-код Java,\n" +
                        " предварительно созданный из исходного текста Java-программы компилятором Java (javac).\n" +
                        " JVM может также использоваться для выполнения программ, написанных на других языках\"" +
                        " программирования."); //ответ 12
        answersList.add(" В Java существуют следующие модификаторы доступа:\n" +
                        " 1) private: (используется конструкторах, внутренних классах, методах и полях класса)\n" +
                        "             - Доступ разрешен только в текущем классе.\n" +
                        " 2) default (package-private): (используется в классах, конструкторах, интерфейсах,\n" +
                        "                                внутренних классах, методах и полях класса)\n" +
                        "                               - Доступ на уровне пакета. Если класс будет так объявлен он\n" +
                        "                                 будет доступен только внутри пакета.\n" +
                        " 3) protected: (используется конструкторах, внутренних классах, методах и полях класса)\n" +
                        "               - Модификатор доступа на уровне пакета и в иерархии наследования.\n" +
                        " 4) public: (используется в классах, конструкторах, интерфейсах, внутренних классах,\n" +
                        "             методах и полях класса) \n" +
                        "            - Модификатор доступа публичный, доступен всем.\n" +
                        " Последовательность модификаторов по убыванию уровня закрытости:\n" +
                        " 1) private,\n" +
                        " 2) default,\n" +
                        " 3) protected,\n" +
                        " 4) public"); //ответ 13
        answersList.add(" Доступ из классов одного package-а в классы другого package-a."); //ответ 14
        answersList.add(" Абстрактный класс это класс, который помечен как 'abstract', он может содержать\n" +
                        " абстрактные методы, а может их и не содержать. Экземпляр абстрактного класса\n" +
                        " нельзя создать. Класс, который наследуется от абстрактного класса может \n" +
                        " реализовывать абстрактные методы, а может и не реализовывать, тогда класс наследник\n" +
                        " должен быть тоже абстрактным. Также если класс наследник переопределяет реализованный\n" +
                        " в абстрактном классе родители метод, его можно переопределить с модификатором абстракт!\n" +
                        " Т.е отказаться от реализации. Соответственно данный класс должен быть также абстрактным\n" +
                        " также. Что касается интерфейса, то в нем находятся только абстрактные методы и константы,\n" +
                        " так было до выхода Java 8. Начиная с Java 8 кроме абстрактных методов мы также можем\n" +
                        " использовать в интерфейсах стандартные методы (default methods) и статические методы\n" +
                        " (static methods). Default метод в интерфейсе - это метод в интерфейсе с по умолчанию\n" +
                        " реализованной логикой, который не требуется обязательно определять в реализации этого\n" +
                        " интерфейса. Static методы в интерфейсе - это по существу то же самое, что static-методы\n" +
                        " в абстрактном классе. При реализации интерфейса, класс обязан реализовать все методы\n" +
                        " интерфейса. Иначе класс должен быть помечен как абстрактный. Интерфейс также может\n" +
                        " содержать внутренние классы. И не абстрактные методы в них. Что же использовать\n" +
                        " Интерфейс или Абстрактный класс? Абстрактный класс используется когда нам нужна\n" +
                        " какая-то реализация по умолчанию. Интерфейс используется когда классу нужно указать\n" +
                        " конкретное поведение. Часто интерфейс и абстрактный класс комбинируют,\n" +
                        " т.е. имплементируют интерфейс в абстрактном классе, чтоб указать поведение и реализацию\n" +
                        " по умолчанию. Это хорошо видно на следующем примере:\n\n" +
                        " class AbstractTableModel implements TableModel{\n" +
                        " }\n" +
                        " class MyTableModel extends AbstractTableModel{\n" +
                        " }\n\n" +
                        " Мы создаем свою модель таблицы с определенным поведением и уже с реализацией\n" +
                        " по умолчанию. ВАЖНО! При реализации интерфейса, необходимо реализовать все его методы,\n" +
                        " иначе будет Fatal error, так же это можно избежать, присвоив слово abstract.\n" +
                        " Пример:\n" +
                        " interface I{\n" +
                        "     public void F();\n" +
                        "     public void say();\n" +
                        " }\n\n" +
                        " public abstract class A implements I{" +
                        "     @Override\n" +
                        "     public void say(){\n" +
                        "         System.out.println(\"Hello!\")\n" +
                        "     }\n" +
                        "     // public void F(); - not implemented\n" +
                        " }"); //ответ 15
        answersList.add(" Вообще доступ у приватной переменной класса можно получить только внутри класса,\n" +
                        " в котором она объявлена. Также доступ к приватным переменным можно осуществить\n" +
                        " через механизм Java Reflection API."); //ответ 16
        answersList.add(" Статические блоки в джава выполняются до выполнения конструктора, с помощью них\n" +
                        " инициализируют статические поля к примеру:\n\n" +
                        " static final int i;\n" +
                        " static{\n" +
                        "     i=10;\n" +
                        " }\n\n" +
                        " Еще один ньюанс, блок статической инициализации может создаваться сам при компиляции программы.\n" +
                        " Например:\n\n" +
                        " public static int MAX = 100;\n\n" +
                        " Будет создан код:\n\n" +
                        " public static int MAX;\n" +
                        " static{\n" +
                        "     MAX = 100;\n" +
                        " };"); //ответ 17
        answersList.add(" Статические методы могут перегружаться нестатическими и наоборот - без ограничений.\n" +
                        " А вот в переопределении статического метода смысла нет."); //ответ 18
        answersList.add(" Внутренний класс - это класс, который находится внутри класса или интерфейса.\n" +
                        " При этом он получает доступ ко всем полям и методам своего внешнего класса.\n" +
                        " Для чего он может применятся? Например чтоб обеспечить какую-то дополнительную\n" +
                        " логику класса. Хотя использование внутренних классов усложняет программу, рекомендуется\n" +
                        " избегать их использование."); //ответ 19
        answersList.add(" Статические переменные инициализируются при загрузке класса класслодером, и не зависят\n" +
                        " от объекта. Переменная экземпляра инициализируется при создании класса.\n" +
                        " Например нам нужна глобальная переменная для всех объектов класс, например число\n" +
                        " посещений пользователей определенной статьи в интернете. При каждом новом посещении\n" +
                        " статьи создается новый объект и инкрементируется переменная посещений."); //ответ 20
        answersList.add(" Статические методы могут быть использованы для &nbsp;инициализации статических\n" +
                        " переменных. Часто статические методы используются в классах утилитах, таких как\n" +
                        " Collections, Math, Arrays"); //ответ 21
        answersList.add(" Любой класс, используемый в джава программу так или иначе был загружен в контекст\n" +
                        " программы каким-то загрузчиком. Все виртуальные машины джава включают хотябы один\n" +
                        " загрузчик классов, так называем базовый загрузчик. Он загружает все основные классы,\n" +
                        " это классы из rt.jar. Интересно то, что этот загрузчик никак не связан с программой,\n" +
                        " тоесть мы не можем получить например у java.lang.Object имя зарузчика, метод\n" +
                        " getClassLoader() вернет нам null. Следующий загрузчик - это &nbsp;загрузчик расширений,\n" +
                        " он загружает классы из $JAVA_HOME/lib/ext. Далее по иерархии идет системный загрузчик,\n" +
                        " он загружает классы, путь к которым указан в переменной ClassPath.\n" +
                        " Для примера предположим что у нас есть некий пользовательский класс MyClass и мы его\n" +
                        " используем. Как идет его загрузка... Сначала системный загрузчик пытается найти его\n" +
                        " в своем кэше загрузок его, если найден - класс успешно загружается, иначе управление\n" +
                        " загрузкой передается загрузчику расширений, он также проверяет свой кэш загрузок\n" +
                        " и в случае неудачи передает задачу базовому загрузчику. Тот проверяет кэш\n" +
                        " и в случае неудачи пытается его загрузить, если загрузка прошла успешно - загрузка\n" +
                        " закончена. Если нет - передает управление загрузчику расширений. Загрузчик расширений\n" +
                        " пытается загрузить класс и в случае неудачи передает это дело системному загрузчику.\n" +
                        " Системный загрузчик пытается загрузить класс и в случае неудачи возбуждается исключение\n" +
                        " java.lang.ClassNotFoundException. Вот так работает загрузка классов в джава.\n" +
                        " Так называемое делегирование загрузки. Если в системе присутствуют\n" +
                        " пользовательские загрузчики, то они должны быть унаследованы от класса\n" +
                        " java.lang.ClassLoader."); //ответ 22
        answersList.add(" Что же такое статическая и что такое динамическая загрузка класса? Статическая загрузка\n" +
                        " класса происходит при использовании оператора \"new\". Динамическая загрузка происходит\n" +
                        " \"на лету\" в ходе выполнения программы с помощью статического метода класса\n" +
                        " Class.forName(имя класса). Для чего нужна динамическая загрузка? Например мы не знаем\n" +
                        " какой класс нам понадобится и принимаем решение в ходе выполнения программы передавая\n" +
                        " имя класса в статический метод forName()."); //ответ 23
        answersList.add(" Это так называемый оператор утверждений. Он проверяет некое &nbsp;условие, если оно ложно,\n" +
                        " то генерируется AssertationError\n" +
                        " assert status: \"message error\";\n" +
                        " Тут проверяется булевская переменная \"status\"."); //ответ 24
        answersList.add(" Это так называемые интерфейсы - маркеры. Они просто указывают что класс относится\n" +
                        " к определенной группе классов. Например интерфейс Clonable указывает на то, что класс\n" +
                        " поддерживает механизм клонирования. \n" +
                        " Интерфейсы-маркери в Java:\n" +
                        " 1) Searilizable interface\n" +
                        " 2) Cloneable interface\n" +
                        " 3) Remote interface\n" +
                        " 4) ThreadSafe interface"); //ответ 25
        answersList.add(" String - неизменяемый класс, тоесть для для добавление данных в уже существующую строку,\n" +
                        " создается новый объект строки.\n" +
                        " StringBuffer и StringBuilder могут изменятся и добавление строки не такое дорогостоющее\n" +
                        " с точки зрения памяти. Первый - синхронизированный, второй - нет. Это их единственное\n" +
                        " различие. Правда если нам нужно сделать подстроку строки, то лучше использовать String,\n" +
                        " так как ее массив символов не меняется и не создается заново для новой строки.\n" +
                        " А вот в StringBuffer и StringBuilder для создания подстроки создается\n" +
                        " новый массив символов."); //ответ 26
        answersList.add(" Потоки ввода-вывода бывают двух видов:\n" +
                        " 1) байтовый поток(InputStream и OutputStream);\n" +
                        " 2) символный поток(Reader и Writer);\n" +
                        " Это все абстрактные классы - декораторы, которым можно добавлять дополнительный функционал,\n" +
                        " например: InputStream in = new FileInputStream(new File(\"file.txt\"));"); // ответ 27
        answersList.add(" Java Heap (куча) - динамически распредляемая область памяти, создаваемая при старте JVM.\n" +
                        " Используется Java Runtime для выделения памяти под объекты и JRE классы. Создание нового\n" +
                        " объекта также происходит в куче. Здесь работает сборщик мусора: освобождает память путем\n" +
                        " удаления объектов, на которые нет каких-либо ссылок. Любой объект, созданный в куче,\n" +
                        " имеет глобальный доступ и на него могут ссылаться с любой части приложения.\n" +
                        " Cтрогими тезами: \n" +
                        " 1) все обьекты обитают в куче и попадают туда при создании.\n" +
                        " 2) обьект состоит из полей класса и методов.\n" +
                        " 3) в куче выделяется место под сам обьект, количество выделенной памяти зависит от полей,\n" +
                        "    если у тебя полем класса, к примеру, служит интовая переменная, то не важно,\n" +
                        "    инициализируешь ты ее как \"0\" или как \"1000000\" - обьект займет в куче свои биты,\n" +
                        "    + столько байт сколько вмещает тип int(+32 бита), и так с каждым полем.\n" +
                        " Стековая память в Java работает по схеме LIFO (Последний-зашел-Первый-вышел).\n" +
                        " Всякий раз, когда вызывается метод, в памяти стека создается новый блок,\n" +
                        " который содержит примитивы и ссылки на другие объекты в методе расположение в RAM\n" +
                        " и достижение процессору через указатель стека. Как только метод заканчивает работу,\n" +
                        " блок также перестает использоваться, тем самым предоставляя доступ для следующего\n" +
                        " метода. Размер стековой памяти намного меньше объема памяти в куче.\n" +
                        " Cтрогими тезами:\n" +
                        " 1) Все методы обитают в стеке и попадают туда при вызове.\n" +
                        " 2) Переменные в методах так же имеют стековую память, по скольку они локальные.\n" +
                        " 3) Если в методе создается обьект, то он помещается в кучу, но его ссылка\n" +
                        "    все еще будет находится в стеке и после того как метод покинет стек - обьект\n" +
                        "    станет жертвой сборщика мусора, так как ссылка на него утеряна, и из главного\n" +
                        "    стека программы невозможно будет добраться до такого обьекта."); //ответ 28
        answersList.add(" Приведем следующие различия между Heap и Stack памятью в Java:\n" +
                        " 1) Куча используется всеми частями приложения в то время как стек\n" +
                        " используется только одним потоком исполнения программы.\n" +
                        " 2) Всякий раз, когда создается объект, он всегда хранится в куче, а в памяти стека\n" +
                        " содержится ссылка на него. Память стека содержит только локальные переменные\n" +
                        " примитивных типов и ссылки на объекты в куче. \n" +
                        " 3) Объекты в куче доступны с любой точки программы, в то время как стековая память\n" +
                        " не может быть доступна для других потоков.\n" +
                        " 4) Управление памятью в стеке осуществляется по схеме LIFO.\n" +
                        " 5) Стековая память существует лишь какое-то время работы программы,\n" +
                        " а память в куче живет с самого начала до конца работы программы.\n" +
                        " 6) Мы можем использовать -Xms и -Xmx опции JVM, чтобы определить начальный\n" +
                        " и максимальный размер памяти в куче. Для стека определить размер памяти можно\n" +
                        " с помощью опции -Xss.\n" +
                        " 7) Если память стека полностью занята, то Java Runtime бросает\n" +
                        " java.lang.StackOverflowError, а если память кучи заполнена, то бросается\n" +
                        " исключение java.lang.OutOfMemoryError: Java Heap Space.\n" +
                        " 8)Размер памяти стека намного меньше памяти в куче. Из-за простоты\n" +
                        " распределения памяти (LIFO), стековая память работает намного быстрее кучи."); //ответ 29
        answersList.add(" В Джаве память устроена следующим образом, есть два вида:\n" +
                        " 1) куча\n" +
                        " 2) стек\n" +
                        " Куча состоит из статического контекста и самой кучи\n" +
                        " Перейдем к куче. Куча состоит из двух частей:\n" +
                        " 1) Новая куча\n" +
                        " 2) Старая куча\n" +
                        " Новая куча в свою очередь состоит из двух частей:\n" +
                        " 1) Eden(назовем ее первая)\n" +
                        " 2) Survival(выжившая) куча\n" +
                        " Краткое описание:\n" +
                        " 1) Eden Space (heap) - в этой области выделятся память под все создаваемые\n" +
                        " из программы объекты. Большая часть объектов живет недолго (итераторы,\n" +
                        " временные объекты, используемые внутри методов и т.п.), и удаляются\n" +
                        " при выполнении сборок мусора это области памяти, не перемещаются в другие\n" +
                        " области памяти. Когда данная область заполняется (т.е. количество выделенной\n" +
                        " памяти в этой области превышает некоторый заданный процент), GC выполняет\n" +
                        " быструю (minor collection) сборку мусора. По сравнению с полной сборкой мусора\n" +
                        " она занимает мало времени, и затрагивает только эту область памяти - очищает от\n" +
                        " устаревших объектов Eden Space и перемещает выжившие объекты в следующую область.\n" +
                        " 2) Survivor Space (heap) - сюда перемещаются объекты из предыдущей, после того,\n" +
                        " как они пережили хотя бы одну сборку мусора. Время от времени долгоживущие объекты\n" +
                        " из этой области перемещаются в Tenured Space." +
                        " 3) Tenured (Old) Generation (heap) - Здесь скапливаются долгоживущие объекты\n" +
                        " (крупные высокоуровневые объекты, синглтоны, менеджеры ресурсов и проч.).\n" +
                        " Когда заполняется эта область, выполняется полная сборка мусора\n" +
                        " (full, major collection), которая обрабатывает все созданные JVM объекты.\n" +
                        " 4) Permanent Generation (non-heap) - Здесь хранится метаинформация, используемая JVM\n " +
                        "(используемые классы, методы и т.п.)."); //ответ 30
        answersList.add(" Во-первых что стоит сказать, что у сборщика мусора есть несколько алгоритмов работы,\n" +
                        " он не один. Когда происходит очистка памяти? Если память в Первой куче полностью заполнена,\n" +
                        " то туда идет сборщик мусора и делает свою работу) Какую именно, зависит от обстоятельств\n" +
                        " Например если в первой кучи много мусора(т.е. объектов с нулевой ссылкой), то сборщик мусора\n" +
                        " помечает эти объекты, далее те что остались объекты со ссылками он их переносит в Выжившую кучу,\n" +
                        " а в первой куче он просто все удаляет. Ситуация другая, в первой кучи мало мусора, но очень много\n" +
                        " рабочих объектов. Как поступает в этом случае сборщик мусора? Он помечает мусор, удаляет его\n" +
                        " и оставшиеся объекты компонует. Также следует заметить что при нехватке места в Выжившей куче,\n" +
                        " объекты переносятся в старую кучу, там хранятся как правило долго живущие объекты.\n" +
                        " Также следует заметить что сборщик мусора вызывается сам периодически, а не только когда\n" +
                        " памяти не хватает."); //ответ 31
        answersList.add(" Приведение &nbsp;типов это установка типа переменной или объекта отличного от текущего.\n" +
                        " В джава есть два вида приведения:\n" +
                        " 1) автоматическое\n" +
                        " 2) не автоматическое\n" +
                        " Автоматическое происходит например:\n" +
                        " byte -> short -> int -> long -> float -> double\n" +
                        " тоесть если мы расширяем тип, то явное преобразование не требуется, приведение происходит\n" +
                        " автоматически. Если же мы сужаем, то необходимо явно указывать приведение типа.\n" +
                        " В случае же с объектами, то мы можем &nbsp;сделать автоматическое приведение\n" +
                        " от наследника к родителю, но никак &nbsp;не наоборот, тогда вылетит ClassCastException."); //ответ 32
        answersList.add(" Статическим классом может быть только внутренний клас(определение класса размещается\n" +
                        " внутри другого класса). В объекте обычного внутреннего класса хранится ссылка на объект\n" +
                        " внешнего класса. Внутри статического внутреннего класса такой ссылки нет.\n" +
                        " То есть: Для создания объекта статического внутреннего класса не нужен объект\n" +
                        " внешнего класса. Из объекта статического вложенного класса нельзя обращаться\n" +
                        " к нестатическим членам внешнего класса напрямую. И еще обычные внутренние классы\n" +
                        " не могут содержать статические методы и члены.\n" +
                        " Зачем вообще нужны внутренние классы? Каждый внутренний класс способен независимо\n" +
                        " наследовать определенную реализацию. Таким образом внутренний класс не ограничен\n" +
                        " при наследовании в ситуациях, когда внешний класс уже наследует реализацию.\n" +
                        " То есть это как бы вариант решения проблемы множественного наследования."); //ответ 33
        answersList.add(" Если класс внутренний, то Внешний_класс.this.поле_внешнего_класса. Если класс\n" +
                        " статический внутренний(вложенный),то в методе нужно создать объект внешнего\n" +
                        " класса, и получить доступ к его полю. Или второй вариант - объявить это поле\n" +
                        " внешнего класса как static"); //ответ 34
        answersList.add(" Вложенные классы существуют внутри других классов. Нормальный класс - полноценный\n" +
                        " член пакета. Вложенные классы, которые стали доступны начиная с Java 1.1, могут быть\n" +
                        " четырех типов:\n" +
                        " 1) статические члены класса\n" +
                        " 2) члены класса\n" +
                        " 3) локальные классы\n" +
                        " 4) анонимные классы\n" +
                        " Статические члены классов (static nested classes) - как и любой другой статический\n" +
                        " метод, имеет доступ к любым статическим методам своего внешнего класса, в том числе\n" +
                        " и к приватным. К нестатическим полям и методам обрамляющего класса он не может\n" +
                        " обращатся напрямую. Он может использовать их только через ссылку на экземпляр класса\n" +
                        " родителя.\n" +
                        " Члены класса - локальные классы, объявленные внутри блока кода. Эти классы видны\n" +
                        " только внутри блока.\n" +
                        " Анонимные классы - Эти типы классов не имеют имени и видны только внутри блока."); //ответ 35
        answersList.add(" 1) Да, если расширять (package -> protected -> public)\n" +
                        " 2) Да, если выполняется Downcasting(понижающее преобразование,\n" +
                        "                                     преобразование вниз по иерархии)\n" +
                        "    то есть возвращаемый тип в переопределенном методе класса наследника\n" +
                        "    должен быть НЕ шире чем в классе родителе (Object -> Number -> Integer)\n" +
                        " 3) Нет, в таком случае происходит Overload(перегрузка)" +
                        " 4) Да" +
                        " 5) Возможно изменять порядок. Возможно вовсе убрать секцию throws в методе,\n" +
                        "    так как она уже определена. Так же возможно добавлять новые исключения,\n" +
                        "    которые наследуются от объявленных или исключения времени выполнения.\n" +
                        " Переопределение методов действует при наследовании классов, т.е. в классе\n" +
                        " наследнике объявлен метод с такой же сигнатурой что и в классе родителе.\n" +
                        " Значит этот метод переопределил метод своего суперкласса.\n" +
                        " Несколько нюансов по этому поводу:" +
                        " 1) Модификатор доступа в методе класса наследника должен быть НЕ уже чем в классе\n" +
                        "    родителе, иначе будет ошибка компиляции.\n" +
                        " 2) Описание исключения в переопределенном методе класса наследника должен быть\n" +
                        "    НЕ шире чем в классе родителе, иначе ошибка компиляции.\n" +
                        " 3) Метод обьявленный как \"private\" в классе родителе нельзя переопределить!"); //ответ 36
        answersList.add(" Autoboxing/Unboxing - автоматическое преобразование между скалярными типами\n" +
                        " Java и соответствующими типами-врапперами (например, между int - Integer).\n" +
                        " Наличие такой возможности сокращает код, поскольку исключает необходимость\n" +
                        " выполнения явных преобразований типов в очевидных случаях."); //ответ 37
        answersList.add(" \"Java Generics\" - это технический термин, обозначающий набор свойств языка\n" +
                        " позволяющих определять и использовать обобщенные типы и методы. Обобщенные типы\n" +
                        " или методы отличаются от обычных тем, что имеют типизированные параметры.\n" +
                        " Примером дженериков или обобщенных типов может служить библитека с коллекциями\n" +
                        " в Java. Например, класс LinkedList<E>; - типичный обобщенный тип.\n" +
                        " Он содержит параметр E, который представляет тип элементов, которые\n" +
                        " будут храниться в коллекции. Вместо того, чтобы просто использовать LinkedList,\n" +
                        " ничего не говоря о типе элемента в списке, мы можем использовать\n" +
                        " LinkedList<String> или LinkedList<Integer>. Создание объектов обобщенных типов\n" +
                        " происходит посредством замены параметризированных типов реальными типами данных.\n" +
                        " Класс типа LinkedList<E> - обобщенный тип, который содержит параметр E. Создание\n" +
                        " объектов, типа LinkedList<String> или LinkedList<Integer> называются\n" +
                        " параметризированными типами, а String и Integer - реальные типы аргументов.\n"); //ответ 38
        answersList.add(" Обобщенные типы в Java были изобретены, в первую очередь, для реализации\n" +
                        " обобщенных коллекций. во вторых - для обеспечения типовой безопасности"); //ответ 39
        answersList.add(" В java параметры в методы передаются по значению, тоесть создаются копии\n" +
                        " параметров и с ними ведется работа в методе. В случае с примитивными типами,\n" +
                        " то при передачи параметра сама переменная не будет меняться так как в метод\n" +
                        " просто копируется ее значение. А вот при передачи объекта копируется ссылка\n" +
                        " на объект, тоесть если в методе мы поменяем состояние объекта, то и за методом\n" +
                        " состояние объекта тоже поменяется. Но если мы этой копии ссылки попытаемся\n" +
                        " присвоить новую ссылку на обьект, то старая ссылка у нас не изменится.\n" +
                        " В случае передачи по значению параметр копируется. Изменение параметра\n" +
                        " не будет заметно на вызывающей стороне. В Java объекты всегда передаются\n" +
                        " по ссылке, а примитивы - по значению."); //ответ 40
        answersList.add(" Object это базовый класс для всех остальных объектов в Java. Каждый класс\n" +
                        " наследуется от Object. Соответственно все классы наследуют методы класса\n" +
                        " Object.\n" +
                        " Методы класса Object:\n" +
                        " 1) public final native Class getClass()\n" +
                        " 2) public native int hashCode()\n" +
                        " 3) public boolean equals(Object obj)\n" +
                        " 4) protected native Object clone() throws CloneNotSupportedException\n" +
                        " 5) public String toString()\n" +
                        " 6) public final native void notify()\n" +
                        " 7) public final native void notifyAll()\n" +
                        " 8) public final native void wait(long timeout) throws InterruptedException\n" +
                        " 9) public final void wait(long timeout, int nanos) throws InterruptedException\n" +
                        "10) public final void wait() throws InterruptedException\n" +
                        "11) protected void finalize() throws Throwable"); //ответ 41
        answersList.add(" 1) Использовать оператор == что бы проверить ссылку на объект, переданную в метод\n" +
                        "    equals. Если ссылки совпадают - вернуть true. Это не обязательно,\n" +
                        "    нужно скорее для оптимизации, но может сэкономить время в случае \"тяжёлых\" \n" +
                        "    сравнений.\n" +
                        " 2) Использовать оператор instanceof для проверки типа аргумента. Если типы\n" +
                        "    не совпадают, вернуть false.\n" +
                        " 3) Преобразовать аргумент к корректному типу. Так как на предыдущем шаге\n" +
                        "    мы выполнили проверку, преобразование корректно.\n" +
                        " 4) Пройтись по всем значимым полям объектов и сравнить их друг с другом.\n" +
                        "    Если все поля равны - вернуть true. Для сравнения простых типов использовать ==.\n" +
                        "    Для полей со ссылкой на объекты использовать equals. float преобразовывать в int\n" +
                        "    с помощью Float.floatToIntBits и сравнить с помощью ==. double преобразовывать\n" +
                        "    в long с помощью Double.doubleToLongBits и сравнить с помощью ==. Для коллекций\n" +
                        "    вышеперечисленные правила применяются к каждому элементу коллекции.\n" +
                        "    Нужно учитывать возможность null полей/объектов. Очерёдность сравнения полей\n" +
                        "    может существенно влиять на производительность.\n" +
                        " 5) Закончив реализацию equals задать себе вопрос, является ли метод симметричным,\n" +
                        "    транзитивным и непротиворечивым.\n" +
                        " И ещё несколько дополнительных правил:\n" +
                        " 1) Переопределив equals, всегда переопределять hashCode.\n" +
                        " 2) Не использовать сложную семантику в equals (типа определения синонимов).\n" +
                        "    equals должен сравнивать поля объектов, не более.\n"); //ответ 42
        answersList.add(" Метод equals() обозначает отношение эквивалентности объектов. Эквивалентным\n" +
                        " называется отношение, которое является симметричным, транзитивным и рефлексивным:\n" +
                        " 1) Рефлексивность: для любого ненулевого x, x.equals(x) вернет true;\n" +
                        " 2) Транзитивность: для любого ненулевого x, y и z, если x.equals(y) и y.eqals(z)\n" +
                        "                    вернет true, тогда и x.equals(z) вернет true;\n" +
                        " 3) Симметричность: для любого ненулевого x и y, x.equals(y) должно вернуть true,\n" +
                        "                    тогда и только тогда, когда y.equals(x) вернет true." +
                        " Также для любого ненулевого x, x.equals(null) должно вернуть false."); //ответ 43
        answersList.add(" Объекты равны, когда a.equals(b) = true и a.hashCode == b.hashcode -> true,\n" +
                        " но необязательно, чтобы два различных объекта возвращали различные хэш коды\n" +
                        " (такая ситуация называется коллизией)."); //ответ 44
        answersList.add(" Реализация метода equals в классе Object сводится к проверке на равенство двух ссылок:\n\n" +
                        " public boolean equals(Object obj) {\n" +
                        "   return(this==obj);\n" +
                        " }\n\n" +
                        " Реализация же метода hashCode класса Object сделана нативной, т.е. определенной\n" +
                        " не с помощью Java-кода:\n\n" +
                        " public native int hashCode();\n\n" +
                        " Он обычно возвращает адрес обьекта в памяти."); //ответ 45
        answersList.add(" Они будут неправильно хранится в контейнерах, использующих хэш коды, таких как\n" +
                        " HashMap, HashSet. Например HashSet хранит элементы в случайном (на первый взгляд)\n" +
                        " порядке. Дело в том, что для быстрого поиска HashSet расчитывает для каждлого\n" +
                        " элемента hashCode и именно по этому ключу ищет и упорядочивает элементы внутри себя"); //ответ 46
        answersList.add(" Есть. Необходимо использовать уникальные, лучше примитивные поля, такие как id, uuid,\n" +
                        " например. Причем, если эти поля задействованы при вычислении hashCode, то нужно их\n" +
                        " задействовать при выполнении equals.\n" +
                        " Общий совет: выбирать поля, которые с большой долью вероятности будут различаться."); //ответ 47
        answersList.add(" Существуют коллекции(HashMap, HashSet), которые используют хэш код, как основу при\n" +
                        " работе с объектами. А если хэш для равных объектов будет разным, то в HashMap будут\n" +
                        " два равных значения, что является ошибкой. Поэтому необходимо соответствующим образом\n" +
                        " переопределить метод hashCode().\n" +
                        " Х Хеширование - преобразование входного массива данных произвольной длины\n" +
                        " в выходную битовую строку фиксированной длины. Такие преобразования также\n" +
                        " называются хеш-функциями или функциями свёртки, а их результаты называют\n" +
                        " хешем или хеш-кодом.\n" +
                        " Хе Хеш-таблице - это структура данных, реализующая интерфейс ассоциативного\n" +
                        " массива, а именно, она позволяет хранить пары (ключ, значение) и выполнять три\n" +
                        " операции: операцию добавления новой пары, операцию поиска и операцию удаления пары\n" +
                        " по ключу.\n" +
                        " Выполнение операции в хеш-таблице начинается с вычисления хеш-функции от ключа.\n" +
                        " Получающееся хеш-значение i = hash(key) играет роль индекса в массиве H. Затем\n" +
                        " выполняемая операция (добавление, удаление или поиск) перенаправляется объекту,\n" +
                        " который хранится в соответствующей ячейке массива H[i].\n" +
                        " Одним из методов построения хеш-функции есть метод деления с остатком\n" +
                        " (division method) состоит в том, что ключу k ставится в соответствие остаток\n" +
                        " от деления k на m, где m - число возможных хеш-значений.\n"); //ответ 48
        answersList.add(" При реализации hashCode используется несколько простых правил.\n" +
                        " Прежде всего, при вычислении хеш-кода следует использовать те же поля,\n" +
                        " которые сравниваются в equals. Это, во-первых, даст равенство хеш-кодов для равных\n" +
                        " обектов, во-вторых, распределено полученное значение будет точно так же, как и\n" +
                        " исходные данные. Теоретически, можно сделать так, чтобы хеш-код всегда был равен 0,\n" +
                        " и это будет абсолютно легальная реализация. Другое дело, что ее ценность будет равна\n" +
                        " тому же самому нулю."); //ответ 49
        answersList.add(" Чтобы объект можно было клонировать, он должен реализовать интерфейс Cloneable(маркер).\n" +
                        " Использование этого интерфейса влияет на поведение метода \"clone\" класс Object.\n" +
                        " Таким образом myObj.clone() создаст нам клон нашего объекта, но этот клон будет\n" +
                        " поверхностный. Что значит поверхностным? Это значит что клонируется только\n" +
                        " примитивные поля класса, ссылочные поля не клонируются! Для того, чтоб произвести\n" +
                        " глубокое клонирование, необходимо в клонируемом классе переопределить метод clone()\n" +
                        " и в нем произвести клонирование изменяемых полей объекта."); //ответ 50
        answersList.add(" Метод clone() в Java используется для клонирования объектов. Т.к. Java работает\n" +
                        " с объектами с помощью ссылок, то простым присваиванием тут не обойдешься, ибо в таком\n" +
                        " случае копируется лишь адрес, и мы получим две ссылки на один и тот же объект, а это\n" +
                        " не то, что нам нужно. Механизм копирования обеспечивает метод clone() класса Object.\n" +
                        " clone() действует как конструктор копирования. Обычно он вызывает метод clone()\n" +
                        " суперкласса и т.д. пока не дойдет до Object. Синтаксис вызова clone() следующий:\n\n" +
                        " Object copy = obj.clone();\n\n" +
                        " или чаще:\n\n" +
                        " MyClass copy = (MyClass)obj.clone();\n\n" +
                        " Один из недостатков метода clone(), это тот факт, что возвращается тип Object,\n" +
                        " поэтому требуется нисходящее преобразование типа. Однако начиная с версии Java\n" +
                        " 1.5 при переопределении метода вы можете сузить возвращаемый тип.\n" +
                        " Пару слов о clone() и final полях. Метод clone() несовместим с final полями.\n" +
                        " Если вы попробуете клонировать final поле компилятор остановит вас.\n" +
                        " Единственное решение - отказаться от final. Ну и пример использования clone():\n\n" +
                        " class MyClass implements Cloneable{\n" +
                        "     public Integer i = 10;\n" +
                        "     public MyClass clone() throws CloneNotSupportedException{\n" +
                        "         MyClass obj = (MyClass)super.clone();\n" +
                        "         obj.i = i;\n" +
                        "         return obj;\n" +
                        "     }\n" +
                        "     public String toString(){\n" +
                        "         return i.toString();\n" +
                        "     }\n" +
                        " }\n" +
                        " public class Temp {\n" +
                        "     public static void main(String[] args) throws CloneNotSupportedException {\n" +
                        "         MyClass a = new MyClass();\n" +
                        "         a.i = 11;\n" +
                        "         MyClass b = a.clone();\n" +
                        "         MyClass c = a;\n" +
                        "         System.out.println(\"a:\" + a + \"b:\" + b + \"c:\" + c);\n" +
                        "         a.i = 12;\n" +
                        "         System.out.println(\"a:\" + a + \"b:\" + b + \"c:\" + c);\n" +
                        "     }\n" +
                        " }\n\n" +
                        " Консоль:\n" +
                        " a:11 b:11 c:11\n" +
                        " a:12 b:11 c:12\n\n" +
                        " Как видите, изменение обьекта a повлекло за собой изменение обьекта c, а вот с b\n" +
                        " все в порядке"); //ответ 51
        answersList.add(" Например в качестве паттерна Синглетон. В том же классе создается статический метод\n" +
                        " где и создается экземпляр класса, конечно если он уже не создан, тогда он просто\n" +
                        " возвращается методом."); //ответ 52
        answersList.add(" В Java если нет явным образом опредёленных конструкторов в классе, то компилятор\n" +
                        " использует конструктор по умолчанию, опредёленный неявным способом, который\n" +
                        " аналогичен \"чистому\", конструктору по умолчанию. Конструктор по умолчанию\n" +
                        " - это довольно простая конструкция, которая сводится к созданию для типа конструктора\n" +
                        " без параметров. Так, например, если при объявлении нестатического класса не объявить\n" +
                        " пользовательский конструктор (не важно, с параметрами или без них), то компилятор\n" +
                        " самостоятельно сгенерирует конструктор без параметров. Некоторые программисты явным\n" +
                        " образом задают конструктор по умолчанию по привычке, чтобы не забыть в дальнейшем,\n" +
                        " но это не обязательно. В Java если производный класс не вызывает явным образом\n" +
                        " конструктор базового класса (в Java используя super() в первой строчке),\n" +
                        " то конструктор по умолчанию вызывается неявно. Если базовый класс не имеет\n" +
                        " конструктора по умолчанию, то это считается ошибкой."); //ответ 53
        answersList.add(" Метод finalize(). Java обеспечивает механизм, который является аналогичным\n" +
                        " использованию деструкторов в С ++, который может использоваться для того,\n" +
                        " чтобы произвести процесс очистки перед возвращением управления операционной системе.\n" +
                        " Применяя метод finalize(), можно определять специальные действия, которые будут\n" +
                        " выполняться тогда, когда объект будет использоваться сборщиком мусора. Данный метод\n" +
                        " вызывается при уничтожении объекта автоматическим сборщиком мусора\n" +
                        " (garbage collector). В классе Object он ничего не делает, однако в классе-наследнике\n" +
                        " позволяет описать все действия, необходимые для корректного удаления объекта,\n" +
                        " такие как закрытие соединений с БД, сетевых соединений, снятие блокировок на файлы\n" +
                        " и т.д. В обычном режиме напрямую этот метод вызывать не нужно, он отработает\n" +
                        " автоматически. Если необходимо, можно обратиться к нему явным образом.\n" +
                        " Его синтаксис:\n\n" +
                        " protected void finalize() throws Throwable\n\n" +
                        " Ссылки не являются собранным мусором. Только объекты - собранный мусор."); //ответ 54
        answersList.add(" final - Нельзя наследоваться от final класса. Нельзя переопределить final метод.\n" +
                        " Нельзя изменить значение final поля.\n" +
                        " finally - используется при обработке ошибок, вызывается всегда, даже если\n" +
                        " произошла ошибка(кроме System.exit(0)). Удобно использовать для освобождения ресурсов.\n" +
                        " finalize() - вызывается перед тем как сборщик мусора будет проводить освобождение\n" +
                        " памяти. Не рекомендуется использовать для освобождения системных ресурсов, так как\n" +
                        " не известно когда сборщик мусора будет производить свою очистку. Вообще данный метод\n" +
                        " мало кто использует. Единственно что можно использовать этот метод для закрытия ресурса\n" +
                        " что должен работать на протяжении всей работы программы и закрываться по ее окончанию.\n" +
                        " Еще можно использовать метод для защиты от так называемых \"дураков\", проверять,\n" +
                        " освобождены ли ресурсы, если нет, то закрыть их."); //ответ 55
        answersList.add(" Все классы-исключения расширяют класс Throwable - непосредственное расширение класса\n" +
                        " Object. У класса Throwable и у всех его расширений по традиции два конструктора:\n" +
                        " Throwable() - конструктор по умолчанию;\n" +
                        " Throwable (String message) - создаваемый\n" +
                        " объект будет содержать произвольное сообщение message.\n" +
                        " Записанное в конструкторе сообщение можно получить затем методом getMessage().\n" +
                        " Если объект создавался конструктором по умолчанию, то данный метод возвратит\n" +
                        " null. Метод toString возвращает краткое описание события, именно он работал\n" +
                        " в предыдущих листингах. Три метода выводят сообщения обо всех методах,\n" +
                        " встретившихся по пути \"полета\" исключения:" +
                        " 1) printstackTrace() - выводит сообщения в стандартный вывод, как правило, это\n" +
                        " консоль;\n" +
                        " 2) printStackTrace(PrintStream stream) - выводит сообщения в байтовый поток stream;\n" +
                        " 3) printStackTrace(PrintWriter stream) - выводит сообщения в символьный поток stream.\n" +
                        " У класса Throwable два непосредственных наследника - классы Error и Exception.\n" +
                        " Они не добавляют новых методов, а служат для разделения классов-исключений на два\n" +
                        " больших семейства - семейство классов-ошибок (error) и семейство собственно\n" +
                        " классов-исключений (exception).\n" +
                        " Классы-ошибки, расширяющие класс Error, свидетельствуют о возникновении сложных\n" +
                        " ситуаций в виртуальной машине Java. Их обработка требует глубокого понимания всех\n" +
                        " тонкостей работы JVM. Ее не рекомендуется выполнять в обычной программе.\n" +
                        " Не советуют даже выбрасывать ошибки оператором throw.\n" +
                        " He следует делать свои классы-исключения расширениями класса Error или какого-то\n" +
                        " его подкласса. Имена классов-ошибок, по соглашению, заканчиваются словом Error.\n" +
                        " Классы-исключения, расширяющие класс Exception, отмечают возникновение обычной\n" +
                        " нештатной ситуации, которую можно и даже нужно обработать. Такие исключения следует\n" +
                        " выбросить оператором throw. Классов-исключений очень много, более двухсот.\n" +
                        " Они разбросаны буквально по всем пакетам J2SDK. В большинстве случаев вы способны\n" +
                        " подобрать готовый класс-исключение для обработки исключительных ситуаций в своей\n" +
                        " программе. При желании можно создать и свой класс-исключение, расширив класс\n" +
                        " Exception или любой его подкласс.\n" +
                        " Среди классов-исключений выделяется класс RuntimeException - прямое расширение\n" +
                        " класса Exception. В нем и его подклассах отмечаются исключения, возникшие при работе\n" +
                        " JVM, но не столь серьезные, как ошибки. Их можно обрабатывать и выбрасывать, расширять\n" +
                        " своими классами, но лучше доверить это JVM, поскольку чаще всего это просто ошибка\n" +
                        " в программе, которую надо исправить. Особенность исключений данного класса в том,\n" +
                        " что их не надо отмечать в заголовке метода пометкой throws. Имена классов-исключений,\n" +
                        " по соглашению, заканчиваются словом Exception."); //ответ 56
        answersList.add(" Все исключительные ситуации можно разделить на две категории: проверяемые(checked)\n" +
                        " и непроверяемые(unchecked). Все исключения, порождаемые от Throwable, можно разбить" +
                        " на три группы. Они определяются тремя базовыми типами: наследниками Throwable -\n" +
                        " классами Error и Exception, а также наследником Exception - RuntimeException." +
                        " Ошибки, порожденные от Exception (и не являющиеся наследниками RuntimeException),\n" +
                        " являются проверяемыми. Т.е. во время компиляции проверяется, предусмотрена ли\n" +
                        " обработка возможных исключительных ситуаций. Как правило, это ошибки, связанные\n" +
                        " с окружением программы (сетевым, файловым вводом-выводом и др.), которые могут\n" +
                        " возникнуть вне зависимости от того, корректно написан код или нет. Например,\n" +
                        " открытие сетевого соединения или файла может привести к возникновению ошибки и\n" +
                        " компилятор требует от программиста предусмотреть некие действия для обработки\n" +
                        " возможных проблем. Таким образом повышается надежность программы, ее устойчивость\n" +
                        " при возможных сбоях." +
                        " Исключения, порожденные от RuntimeException, являются непроверяемыми и компилятор\n" +
                        " не требует обязательной их обработки." +
                        " Как правило, это ошибки программы, которые при правильном кодировании возникать\n" +
                        " не должны (например, IndexOutOfBoundsException- выход за границы массива,\n" +
                        " java.lang.ArithmeticException - деление на ноль). Поэтому, чтобы не загромождать\n" +
                        " программу, компилятор оставляет на усмотрение программиста обработку таких исключений\n" +
                        " с помощью блоков try-catch. Исключения, порожденные от Error, также не являются\n" +
                        " проверяемыми. Они предназначены для того, чтобы уведомить приложение о возникновении\n" +
                        " фатальной ситуации, которую программным способом устранить практически невозможно\n" +
                        " (хотя формально обработчик допускается). Они могут свидетельствовать об ошибках\n" +
                        " программы, но, как правило, это неустранимые проблемы на уровне JVM. В качестве\n" +
                        " примера можно привести StackOverflowError (переполнение стека), OutOfMemoryError\n" +
                        " (нехватка памяти). Методы, код которых может порождать проверяемые исключения,\n" +
                        " должны либо сами их обрабатывать, либо в заголовке метода должно быть указано\n" +
                        " ключевое слово throws с перечислением необрабатываемых проверяемых исключений.\n" +
                        " На непроверяемые ошибки это правило не распространяется. Переопределенный\n" +
                        " (overridden) метод не может расширять список возможных исключений исходного метода."); //ответ 57
        answersList.add(" Checked исключения, это те, которые должны обрабатываться блоком catch или описываться\n" +
                        " в сигнатуре метода. Unchecked могут не обрабатываться и не быть описанными.\n" +
                        " Unchecked исключения в Java - наследованные от RuntimeException,\n" +
                        " Checked - от Exception. Пример unchecked исключения - NullPointerException,\n" +
                        " checked исключения - IOException."); //ответ 58
        answersList.add(" Унаследоваться от RuntimeException."); //ответ 59
        answersList.add(" ____________________________________________________________________________\n" +
                        " Исключение: ArithmeticException\n" +
                        " Значение  : Арифметическая ошибка: деление на нуль и др.\n" +
                        " ____________________________________________________________________________\n" +
                        " Исключение: ArrayIndexOutOfBoundsException\n" +
                        " Значение  : Индекс массива находится вне границ\n" +
                        " ____________________________________________________________________________\n" +
                        " Исключение: ArrayStoreException\n" +
                        " Значение  : Назначение элементу массива несовместимого типа\n" +
                        " ____________________________________________________________________________\n" +
                        " Исключение: ClassCastException\n" +
                        " Значение  : Недопустимое приведение типов\n" +
                        " ____________________________________________________________________________\n" +
                        " Исключение: ConcurrentModificationException\n" +
                        " Значение  : Некорректная модификация коллекции\n" +
                        " ____________________________________________________________________________\n" +
                        " Исключение: IllegalArgumentException\n" +
                        " Значение  : При вызове метода использован незаконный аргумент\n" +
                        " ____________________________________________________________________________\n" +
                        " Исключение: IllegalMonitorStateException\n" +
                        " Значение  : Незаконная операция монитора на разблакированном экземпляре\n" +
                        " ____________________________________________________________________________\n" +
                        " Исключение: IllegalStateException\n" +
                        " Значение  : Среда или приложение находится в некорректном состоянии\n" +
                        " ____________________________________________________________________________\n" +
                        " Исключение: IllegalThreadStateException\n" +
                        " Значение  : Требуемая операция несовместима с текущим состоянием потока\n" +
                        " ____________________________________________________________________________\n" +
                        " Исключение: IndexOutOfBoundsException\n" +
                        " Значение  : Некоторый тип индекса находится вне границ\n" +
                        " ____________________________________________________________________________\n" +
                        " Исключение: NegativeArraySizeException\n" +
                        " Значение  : Массив создавался с отрицательным размером\n" +
                        " ____________________________________________________________________________\n" +
                        " Исключение: NullPointerException\n" +
                        " Значение  : Недопустимое использование нулевой ссылки\n" +
                        " ____________________________________________________________________________\n" +
                        " Исключение: NumberFormatException\n" +
                        " Значение  : Недопустимое преобразование строки в числовой формат\n" +
                        " ____________________________________________________________________________\n" +
                        " Исключение: StringIndexOutOfBoundsException\n" +
                        " Значение  : Попытка индексации вне границ строки\n" +
                        " ____________________________________________________________________________\n" +
                        " Исключение: UnsupportedOperationException\n" +
                        " Значение  : Встретилась неподдерживаемая операция\n" +
                        " ____________________________________________________________________________"); //ответ 60
        answersList.add(" Исключения, порожденные от Error, не являются проверяемыми. Они предназначены\n" +
                        " для того, чтобы уведомить приложение о возникновении фатальной ситуации, которую\n" +
                        " программным способом устранить практически невозможно (хотя формально обработчик\n" +
                        " допускается). Они могут свидетельствовать об ошибках программы, но, как правило,\n" +
                        " это неустранимые проблемы на уровне JVM. В качестве примера можно привести\n" +
                        " StackOverflowError (переполнение стека), OutOfMemoryError (нехватка памяти).\n" +
                        " Методы, код которых может порождать проверяемые исключения, должны либо сами\n" +
                        " их обрабатывать, либо в заголовке метода должно быть указано ключевое слово\n" +
                        " throws с перечислением необрабатываемых проверяемых исключений. На непроверяемые\n" +
                        " ошибки это правило не распространяется."); //ответ 61
        answersList.add(" Если срабатывает один из блоков catch, то остальные блоки в данной конструкции\n" +
                        " try-catch выполняться не будут. Cвойством транзакционности исключения не обладают\n" +
                        " - действия, произведенные в блоке try до возникновения исключения, не отменяются\n" +
                        " поcле его возникновения."); //ответ 62
        answersList.add(" try может быть в паре с finally, без catch. Работает это точно так же - после\n" +
                        " выхода из блока try выполняется блок finally. Это может быть полезно, например,\n" +
                        " в следующей ситуации. При выходе из метода вам надо произвести какое-либо\n" +
                        " действие. А return в этом методе стоит в нескольких местах. Писать одинаковый код\n" +
                        " перед каждым return нецелесообразно. Гораздо проще и эффективнее поместить основной\n" +
                        " код в try, а код, выполняемый при выходе - в finally."); //ответ 63
        answersList.add(" Не всегда например в следующих ситуациях:\n" +
                        " 1) Существуют потоки-демоны - потоки предоставляющие некие сервисы, работая в фоновом\n" +
                        "    режиме во время выполнения программы, но при этом не являются ее неотъемлеммой частью.\n" +
                        "    Таким образом когда все потоки не демоны завершаются, программа завершает свою работу.\n" +
                        "    В потоках демонах блок finally не выполняеться, они прерываются внезапно." +
                        " 2) System.exit(0);" +
                        " 3) если в блоке finally произошло исключение и нет обработчика, то оставшийся код в блоке\n" +
                        "    finally может не выполнятся."); //ответ 64
        answersList.add(" 1) Внутреннее состояние класса String нельзя изменить после его создания, т.е. этот класс\n" +
                        "    неизменяемый (immutable) поэтому когда вы пишете String str = \"One\" + \"Two\";\n" +
                        "    создается три! объекта класса String.\n" +
                        " 2) От него нельзя унаследоваться, потому что класс String объявлен как final:\n" +
                        "    public final class String" +
                        " 3) Метод hashCode класса String переписан и возвращает:\n" +
                        "    s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]\n" +
                        " 4) У класса String есть метод public String intern(), который возвращает строку\n" +
                        "    в каноническом ее представлении из внутреннего пула строк, поддерживаемого JVM,\n" +
                        "    он нужен чтобы вместо String.equals() использовать ==.\n" +
                        " Понятно, что оператор сравнения ссылок выполняется гораздо быстрее, чем посимвольное\n" +
                        " сравнение строк. Используют в основном, где приходится сравнивать много строк, например\n" +
                        " в каких нибудь XML парсерах. А вообще по увеличению производительности ещё вопрос.\n" +
                        " Ибо метод intern() тогда должен выполняться быстрее чем equals(), каждый раз когда\n" +
                        " вы вызываете метод intern() просматривается пул строк на наличие такой строки и если\n" +
                        " такая уже есть в пуле, то возвращается ссылка на нее.Сравниваются они через equal()."); //ответ 65
        answersList.add(" Классы объявлены final, поэтому наследоваться не получится."); //ответ 66
        answersList.add(" Поскольку строки неизменны, их хэшкод кэшируется в момент создания, и не требует\n" +
                        " повторного пересчета. Это делает строки отличным кандидатом для ключа в Map и они\n" +
                        " обрабатываются быстрее, чем другие объекты-ключи HashMap. Вот почему строки\n" +
                        " преимущественно используются в качестве ключей HashMap."); //ответ 67
        answersList.add(" Конкатенация - операция объединения строк. Результатом является объединения\n" +
                        " второй строки с окончанием первой. Операция конкатенации могут быть выполнены\n" +
                        " так:\n\n" +
                        " StringBuffer stringBuffer = new StringBuffer();\n" +
                        " StringBuilder stringBuilder = new StringBuilder();\n" +
                        " String str = \"ABC\"\n\n" +
                        " str += \"DEF\";\n" +
                        " String str2 = \"one\".concat(\"two\").concat(\"three\");\n" +
                        " stringBuffer.append(\"DDD\").append(\"EEE\");\n" +
                        " stringBuilder.append(\"FFF\").append(\"GGG\");\n\n" +
                        " System.out.println(str); //output: ABCDEF\n" +
                        " System.out.println(str2); //output: onetwothree\n" +
                        " System.out.println(stringBuffer.toString()); //output: DDDEEE\n" +
                        " System.out.println(stringBuilder.toString()); //output: FFFGGG"); //ответ 68
        answersList.add(" Один из способов как это можно сделать:\n" +
                        " String s = \"ABCDEFG\";\n" +
                        " StringBuilder stringBuilder = new StringBuilder(s);\n" +
                        " stringBuilder.reverse();\n" +
                        " System.out.println(stringBuilder.toString()); // GFEDCBA"); //ответ 69
        answersList.add(" Строка в Java - это отдельный объект, который может не совпадать с другим объектом,\n" +
                        " хотя на экране результат выводимой строки может выглядеть одинаково.\n" +
                        " Оператор == (а также !=) работает с ссылками объекта String. Если две переменные\n" +
                        " String указывают на один и тот же объект в памяти, сравнение вернет результат true.\n" +
                        " В противном случае результат будет false, несмотря на то что текст может содержать\n" +
                        " в точности такие же символы. Для сравнения посимвольно на эквивалентность необходимо\n" +
                        " использовать метод equals().\n\n" +
                        " String s1 = new String(\"ABC\");\n" +
                        " String s2 = new String(\"ABC\");\n" +
                        " String s3 = \"ABC\";\n" +
                        " String s4 = \"ABC\";\n\n" +
                        " System.out.println(s1 == s2); // false\n" +
                        " System.out.println(s3 == s4); // true. Т.к. один набор литералов будет\n" +
                        "                               // указывать на одну область памяти\n" +
                        " System.out.println(s1.equals(s2)); //true\n" +
                        " s1 = s2;\n" +
                        " System.out.println(s1 == s2); //true\n" +
                        " if (\"someString\" == \"someString\"){ //true\n" +
                        " System.out.println(\"true\");\n" +
                        " }"); //ответ 70
        answersList.add(" Небольшой пример:\n" +
                        " String s = \"   a   \";\n" +
                        " System.out.println(s.trim()+\"b\"); // ab\n" +
                        " System.out.println(s + \"b\"); //   a   b"); //ответ 71
        answersList.add(" Пул строк - это набор строк, который хранится в памяти Java heap.\n" +
                        " Мы знаем, что String это специальный класс в Java, и мы можем\n" +
                        " создавать объекты этого класса, используя оператор new точно так же,\n" +
                        " как и создавать объекты, предоставляя значение строки в двойных кавычках.\n" +
                        " Пул строк возможен исключительно благодаря неизменяемости строк в Java\n" +
                        " и реализации идеи интернирования строк. Пул строк помогает экономить\n" +
                        " большой объем памяти, но с другой стороны создание строки занимает больше\n" +
                        " времени. Когда мы используем двойные кавычки для создания строки, сначала\n" +
                        " ищется строка в пуле с таким же значением, если находится, то просто\n" +
                        " возвращается ссылка, иначе создается новая строка в пуле, а затем\n" +
                        " возвращается ссылка. Тем не менее, когда мы используем оператор new,\n" +
                        " мы принуждаем класс String создать новый объект строки, а затем мы можем\n" +
                        " использовать метод intern() для того, чтобы поместить строку в пул,\n" +
                        " или получить из пула ссылку на другой объект String с таким же значением."); //ответ 72
        answersList.add(" String сам по себе потокобезопасный класс. Если мы мы работаем с изменяемыми\n" +
                        " строками, то нужно использовать StringBuffer."); //ответ 73
        answersList.add(" Привести их к одному типу и сравнить."); //ответ 74
        answersList.add(" Есть несколько преимуществ в неизменности строк:\n" +
                        " 1) Строковый пул возможен только потому, что строка неизменна в Java,\n" +
                        "    таким образом виртуальная машина сохраняет много места в памяти(heap space),\n" +
                        "    поскольку разные строковые переменные указывают на одну переменную в пуле.\n" +
                        "    Если бы строка не была неизмененяемой, тогда бы интернирование строк\n" +
                        "    не было бы возможным, потому что если какая-либо переменная изменит значение,\n" +
                        "    это отразится также и на остальных переменных, ссылающихся на эту строку.\n" +
                        " 2) Если строка будет изменяемой, тогда это станет серьезной угрозой безопасности\n" +
                        "    приложения. Например, имя пользователя базы данных и пароль передаются строкой\n" +
                        "    для получения соединения с базой данных и в программировании сокетов реквизиты\n" +
                        "    хоста и порта передаются строкой. Так как строка неизменяемая, её значение\n" +
                        "    не может быть изменено, в противном случае любой хакер может изменить значение\n" +
                        "    ссылки и вызвать проблемы в безопасности приложения.\n" +
                        " 3) Строки используются в Java classloader и неизменность обеспечивает правильность\n" +
                        "    загрузки класса при помощи Classloader. К примеру, задумайтесь об экземпляре\n" +
                        "    класса, когда вы пытаетесь загрузить java.sql.Connection класс, но значение ссылки\n" +
                        "    изменено на myhacked.Connection класс, который может осуществить нежелательные вещи\n" +
                        "    с вашей базой данных.\n" +
                        " 4) Поскольку строка неизменная, её hashcode кэшируется в момент создания и нет\n" +
                        "    необходимости рассчитывать его снова. Это делает строку отличным кандидатом\n" +
                        "    для ключа в Map и его обработка будет быстрее, чем других ключей HashMap.\n" +
                        "    Это причина, почему строка наиболее часто используемый объект, используемый\n" +
                        "    в качестве ключа HashMap."); //ответ 75
        answersList.add(" Мы можем использовать метод replaceAll для замены всех вхождений в строку другой\n" +
                        " строкой. Обратите внимание на то, что метод получает в качестве аргумента строку,\n" +
                        " поэтому мы используем класс Character для создания строки из символа, и используем\n" +
                        " её для замены всех символов на пустую строку:\n\n" +
                        " public static String removeChar(String str, char ch) {\n" +
                        "     return str == null ? null : str.replaceAll(Character.toString(ch),\"\");\n" +
                        " }"); //ответ 76
        answersList.add(" Рефлексия используется для получения или модификации информации о типах во время\n" +
                        " выполнения программы. Этот механизм позволяет получить сведения о классах,\n" +
                        " интерфейсах, полях, методах, конструкторах во время исполнения программы.\n" +
                        " При этом не нужно знать имена классов, методов или интерфейсов.\n" +
                        " Также этот механизм позволяет создавать новые объекты, выполнять методы и получать\n" +
                        " и устанавливать значения полей."); //ответ 77
        answersList.add(" Во время старта JVM запускается поток finalizer, который работает в фоне.\n" +
                        " Этот поток имеет метод runFinalizer, который игнорирует все исключения методов\n" +
                        " finalize объектов перед сборкой мусора. То есть если во время выполнения метода\n" +
                        " finalize возникнет исключительная ситуация, его выполнение будет остановлено\n" +
                        " и это никак не скажется на работоспособности самого сборщика мусора\n" +
                        " (garbage collector)."); //ответ 78
        answersList.add(" Интернационализация (internationalization, а для краткости - i18n) - такой способ\n" +
                        " создания приложений, при котором их можно легко адаптировать для разных аудиторий,\n" +
                        " говорящих на разных языках. Локализация localization а для краткости - l10n)\n" +
                        " - адаптация интерфейса приложения под несколько языков. Добавление нового языка\n" +
                        " может внести определенные сложности в локализацию интерфейса."); //ответ 79
        answersList.add(" Аннотации - это своего рода метатеги, которые добавляются к коду и применяются\n" +
                        " к объявлению пакетов, классов, конструкторов, методов, полей, параметров и локальных\n" +
                        " переменных. Аннотации всегда обладают некоторой информацией и связывают эти\n" +
                        " \"дополнительные данные\" и все перечисленные конструкции языка.\n" +
                        " Фактически аннотации представляют собой их дополнительные модификаторы,\n" +
                        " применение которых не влечет за собой изменений ранее созданного кода."); //ответ 80
        answersList.add(" Аннотация выполняет следующие функции:\n" +
                        " 1) дает необходимую информацию для компилятора;\n" +
                        " 2) дает информацию различным инструментам для генерации другого кода, конфигураций\n" +
                        "    и т. д.;\n" +
                        " 3) может использоваться во время работы кода;\n" +
                        " Самая часто встречаемая аннотация, которую встречал любой программист,\n" +
                        " даже начинающий это @Override."); //ответ 81
        answersList.add(" В языке Java SE определено несколько встроенных аннотаций, большинство\n" +
                        " из их являются специализированными. Четыре типа @Retention, @Documented,\n" +
                        " @Target и @Inherited - из пакета java.lang.annotation.\n" +
                        " Из оставшиеся выделяются - @Override, @Deprecated, @SafeVarargs и @SuppressWarnings\n" +
                        " - из пакета java.lang. Широкое использование аннотаций в различных технологиях\n" +
                        " и фреймворках обуславливается возможностью сокращения кода и снижения его связанности."); //ответ 82
        answersList.add(" Эти аннотации, имеют следующее значение:\n" +
                        " 1) @Retention - эта аннотация предназначена для применения только в качестве аннотации\n" +
                        "    к другим аннотациям, позволяет указать жизненный цикл аннотации: будет она\n" +
                        "    присутствовать только в исходном коде, в скомпилированном файле, или она будет также\n" +
                        "    видна и в процессе выполнения. Выбор нужного типа зависит от того, как вы хотите\n" +
                        "    использовать аннотацию.\n" +
                        " 2) @Documented - это маркер-интерфейс, который сообщает инструменту, что аннотация\n" +
                        "    должна быть документирована.\n" +
                        " 3) @Target - эта аннотация задает тип объявления, к которым может быть применима\n" +
                        "    аннотация. Принимает один аргумент, который должен быть константой из перечисления\n" +
                        "    ElementType, это может быть поле, метод, тип и т.д. Например, чтобы указать, что\n" +
                        "    аннотация применима только к полям и локальным переменным:\n" +
                        "    @Targer({ ElementType.FIELD, ElementTyle.LOCAL_VARIABLE })\n" +
                        " 4) @Inherited - это аннотация-маркер, которая может применяться в другом объявление\n" +
                        "    аннотации, она касается только тех аннотаций, что будут использованы в объявлениях\n" +
                        "    классов. Эта аннотация позволяет аннотации супер класса быть унаследованной\n" +
                        "    в подклассе."); //ответ 83
        answersList.add(" Эти аннотации предназначены для:\n" +
                        " 1) @Override - аннотация-маркер, которая может применяться только к методам. Метод,\n" +
                        "    аннотированный как @Override, должен переопределять метод супер класса.\n" +
                        " 2) @Deprecated - указывает, что объявление устарело и должно быть заменено более\n" +
                        "    новой формой.\n" +
                        " 3) @SafeVarargs - аннотация-маркер, применяется к методам и конструкторам.\n" +
                        "    Она указывает, что никакие небезопасные действия, связанные с параметром\n" +
                        "    переменного количества аргументов, недопустимы. Применяется только к методам\n" +
                        "    и конструкторам с переменным количеством аргументов, которые объявлены как\n" +
                        "    static или final.\n" +
                        " 4) @SuppressWarnings - эта аннотация указывает, что одно или более предупреждений,\n" +
                        "    которые могут быть выданы компилятором следует подавить."); //ответ 84
        answersList.add(" Существует 3 возможные варианты чтобы указать где аннотация будет жить.\n" +
                        " Они инкапсулированы в перечисление java.lang.annotation.RetentionPolicy.\n" +
                        " Это SOURCE, CLASS, RUNTIME.\n" +
                        " 1) SOURCE - содержаться только в исходном файле и отбрасываются при компиляции.\n" +
                        " 2) CLASS - сохраняются в файле, однако они недоступны JVM во время выполнения.\n" +
                        " 3) RUNTIME - сохраняются в файле во время компиляции и остаются доступными JVM\n" +
                        "    во время выполнения."); //ответ 85
        answersList.add(" Для того чтобы ограничить использование аннотации её нужно проаннотировать.\n" +
                        " Для этого существует аннотация @Target:\n" +
                        " 1) @Target(ElementType.PACKAGE) - только для пакетов;\n" +
                        " 2) @Target(ElementType.TYPE) - только для классов;\n" +
                        " 3) @Target(ElementType.CONSTRUCTOR) - только для конструкторов;\n" +
                        " 4) @Target(ElementType.METHOD) - только для методов;\n" +
                        " 5) @Target(ElementType.FIELD) - только для атрибутов(переменных) класса;\n" +
                        " 6) @Target(ElementType.PARAMATER) - только для параметров метода;\n" +
                        " 7) @Target(ElementType.LOCAL_VARIABLE) - только для локальных переменных.\n" +
                        " В случае если вы хотите, что бы ваша аннотация использовалась больше чем\n" +
                        " для одного типа параметров, то можно указать @Target следующим образом:\n\n" +
                        " @Target({ElementType.PARAMETER, ElementType.LOCAL_VARIABLE})\n\n" +
                        " тут мы говорим, аннотацию можно использовать только для параметров метода\n" +
                        " и для локальных переменных."); //ответ 86
        answersList.add(" Написать свою аннотацию не так сложно, как могло бы казаться. В следующем\n" +
                        " коде приведено объявление аннотации:\n\n" +
                        " public @interface About{\n" +
                        "     String info() default\"\";\n" +
                        " }\n\n" +
                        " как вы видите на месте где обычно пишут class или interface у нас написано\n" +
                        " @interface. Структура практически та же, что и у интерфейсов, только пишется\n" +
                        " @interface:\n" +
                        " 1) @interface - указывает на то, что это аннотация\n" +
                        " 2) default - говорит про то, что метод по умолчанию будет возвращать определённое\n" +
                        "    значение.\n" +
                        " Аннотация готова теперь ею можно пользоваться, также аннотацию можно сконфигурировать."); //ответ 87
        answersList.add(" Атрибуты могут иметь только следующие типы:\n" +
                        " примитивы\n" +
                        " 1) String\n" +
                        " 2) Class или <<any parameterized invocation of Class>>;\n" +
                        " 3) enum\n" +
                        " 4) annotation\n" +
                        " 5) массив элементов любого из вышеперечисленных типов\n" +
                        " Последний пункт надо понимать как то, что допустимы только одномерные массивы."); //ответ 88
        answersList.add(" Управленческие расширения Java (Java Management Extensions, JMX) - API при помощи\n" +
                        " которого можно контролировать работу приложений и управлять различными параметрами\n" +
                        " удаленно в реальном времени. Причем управлять можно фактически чем угодно - лишь бы\n" +
                        " это было написано на Java. Это может быть микро-устройство типа считывателя отпечатка\n" +
                        " или система, включающая тысячи машин, каждая из которых предоставляет определенные\n" +
                        " сервисы. Данные ресурсы представляются MBean-объектами (управляемый Java Bean).\n" +
                        " JMX вошла в поставку Java начиная с версии 5."); //ответ 89
        answersList.add(" Вот как эти выгоды описывает Sun:\n" +
                        " 1) Простота реализации. Архитектура JMX основана на понятии\n" +
                        "    \"сервера управляемых объектов\" который выступает как управляющий агент и может быть\n" +
                        "    запущен на многих устройствах/компьютерах, которые поддерживают JAVA.\n" +
                        " 2) Масштабируемость. Службы агентов JXM являются независимыми и могут быть встроены\n" +
                        "    наподобие \"plug-in\" - ов в агента JMX. Компонентно-основанаая система позволяет\n" +
                        "    создавать масштабируемые решения от крохотных устройств до очень крупных систем.\n" +
                        " 3) Возможность расширять концепцию в будущем. JMX позволяет создавать гибкие решения.\n" +
                        "    Например, JMX позволяет создавать удобные решения, которые могут находить различные\n" +
                        "    сервисы.\n" +
                        " 4) Концентрация на управлении. JMX предоставляет сервися, разработанные для работы\n" +
                        "    в распределенных средах и его API спроектировано для решений, которые управляют\n" +
                        "    приложениями, сетями, сервисами и т.д."); //ответ 90
        answersList.add(" JMX делает гораздо больше, чем просто предоставляет рабочую оболочку для\n" +
                        " дистанционного управления. Она обеспечивает дополнительные услуги (services),\n" +
                        " способные занять ключевое место в процессе разработки. Приведу лишь краткое\n" +
                        " описание:\n" +
                        " 1) Event notification: Интерфейсы оповещают исполнителей и слушателей о событиях\n" +
                        "    типа изменения атрибута, что позволяет MBean-компонентам общаться с другими\n" +
                        "    MBean-компонентами или удалённым \"командным пунктом\" и докладывать об изменениях\n" +
                        "    своего состояния\n" +
                        " 2) Monitor service: Monitor MBeans может посылать уведомления о событиях\n" +
                        "    зарегистрированным слушателям. Слушателем может выступать другой MBean или\n" +
                        "    управляющее приложение. В качестве основных атрибутов, для которых используется\n" +
                        "    данное свойство, являются counter, gauge или string.\n" +
                        " 3) Timer service: Timer MBean будет посылать уведомления зарегистрированным\n" +
                        "    слушателям, с учётом определённого числа или временного промежутка.\n" +
                        " 4) M-let service: М-let service может создавать и регистрировать экземпляры\n" +
                        "    MBean-серверов. Список MBean-компонентов и имён из классов определяются\n" +
                        "    в m-let-файле с помощью MLET - меток. URL указывает на месторасположения\n" +
                        "    m-let-файла."); //ответ 91
        answersList.add(" MBeans - это Java-объекты, которые реализуют определенный интерфейс. Интерфейс\n" +
                        " включает:\n" +
                        " 1) некие величины, которые могут быть доступны;\n" +
                        " 2) операции, которые могут быть вызваны;\n" +
                        " 3) извещения, которые могут быть посланы;\n" +
                        " 4) конструкторы."); //ответ 92
        answersList.add(" Существует 4 типа MBeans:\n" +
                        " 1) Standard MBeans. Самые простые бины. Их управляющий интерфейс определяется\n" +
                        "    набором методов\n" +
                        " 2) Dynamic MBeans. Они реализуют специализированный интерфейс, который делают\n" +
                        "    доступным во время исполнения.\n" +
                        " 3) Open MBeans. Это Dynamic MBeans, которые используют только основные типы данных\n" +
                        "    для универсального управления.\n" +
                        " 4) Model MBeans. Это Dynamic MBeans, которые полностью конфигурируемы и могут\n" +
                        "    показать свое описание во время исполнения (нечто вроде Reflection)"); //ответ 93
        answersList.add(" MBean Server - это реестр объектов, которые используются для управления.\n" +
                        " Любой объект зарегистрированный на сервере становится доступным для приложений.\n" +
                        " Надо отметить, что сервер публикует только интерфейсы и не дает прямых ссылок\n" +
                        " на объекты. Любые ресурсы, которыми вы хотите управлять должны быть зарегистрированы\n" +
                        " на сервере как MBean. Сервер предоставляет стандартный интерфейс для доступа к MBean.\n" +
                        " Интересно, что регистрировать MBean может любой другой MBean, сам агент или удаленное\n" +
                        " приложение через распределенные сервисы. Когда вы регистрируете MBean вы должны\n" +
                        " дать ему уникальное имя, которое будет использовано для обращения к даному объекту."); //ответ 94
        answersList.add(" В технологии Java безопасность обеспечивают следующие три механизма:\n" +
                        " 1) структурные функциональные возможности языка (например, проверка границ массивов,\n" +
                        "    запрет на преобразования непроверенных типов, отсутствие указателей и т.д.)." +
                        " 2) средства контроля доступа, определяющие действия, которые разрешается или\n" +
                        "    запрещается выполнять в коде (например, может ли код получать доступ к файлам,\n" +
                        "    передавать данные по сети и т.д.).\n" +
                        " 3) механизм цифровой подписи, предоставляющий авторам возможность применять\n" +
                        "    стандартные алгоритмы для аутентификации своих программ, а пользователям - точно\n" +
                        "    определять, кто создал код и изменился ли он с момента его подписания."); //ответ 95
        answersList.add(" Ниже приведены некоторые виды проверок, выполняемых верификатором:\n" +
                        " 1) инициализация переменных перед их использованием.\n" +
                        " 2) согласование типов ссылок при вызове метода.\n" +
                        " 3) соблюдение правил доступа к закрытым данным и методам.\n" +
                        " 4) доступ к локальным переменным в стеке во время выполнения.\n" +
                        " 5) отсутствие переполнения стека.\n" +
                        " При невыполнении какой-нибудь из этих проверок класс считается поврежденным\n" +
                        " и загружаться не будет."); //ответ 96
        answersList.add(" В качестве диспетчера защиты служит класс, определяющий, разрешено ли коду\n" +
                        " выполнять ту или иную операцию. Ниже перечислены операции, подпадающие под\n" +
                        " контроль диспетчера защиты. Существует немало других проверок, выполняемых\n" +
                        " диспетчером защиты в библиотеке Java:\n" +
                        " 1) создание нового загрузчика классов.\n" +
                        " 2) выход из виртуальной машины.\n" +
                        " 3) получение доступа к члену другого класса с помощью рефлексии.\n" +
                        " 4) получение доступа к файлу.\n" +
                        " 5) установление соединения через сокет.\n" +
                        " 6) запуск задания на печать.\n" +
                        " 7) получение доступа к системному буферу обмена.\n" +
                        " 8) получение доступа к очереди событий в AWT.\n" +
                        " 9) обращение к окну верхнего уровня.");  //ответ 97
        answersList.add(" JAAS (Java Authentication and Authorization Service - служба аутентификации\n" +
                        " и авторизации Java) - служба JAAS, по существу, представляет собой\n" +
                        " встраиваемый прикладной интерфейс API, отделяющий прикладные программы\n" +
                        " на Java от конкретной технологии, применяемой для реализации средств\n" +
                        " аутентификации. Помимо прочего, эта служба поддерживает механизмы\n" +
                        " регистрации в UNIX и NT, механизм аутентификации Kerberos и механизмы\n" +
                        " аутентификации по сертификатам. После аутентификации за пользователем\n" +
                        " может быть закреплен определенный набор полномочий. Входит в состав\n" +
                        " платформы Java начиная с версии Java SE 1.4."); //ответ 98
        answersList.add(" Рефакторинг - процесс изменения внутренней структуры программы,\n" +
                        " не затрагивающий её внешнего поведения и имеющий целью облегчить понимание\n" +
                        " её работы. В основе рефакторинга лежит последовательность небольших\n" +
                        " эквивалентных (то есть сохраняющих поведение) преобразований.."); //ответ 99

        //3) JAVA COLLECTIONS FRAMEWORK
        answersList.add(" Коллекции - это хранилища или контейнеры, поддерживающие различные способы\n" +
                        " накопления и упорядочения объектов с целью обеспечения возможностей\n" +
                        " эффективного доступа к ним. Они представляют собой реализацию абстрактных\n" +
                        " структур данных, поддерживающих три основные операции:\n" +
                        " 1) добавление нового элемента в коллекцию;\n" +
                        " 2) удаление элемента из коллекции;\n" +
                        " 3) изменение элемента в коллекции."); //ответ 100
        answersList.add(" Сollection расширяет три интерфейса: List, Set, Queue.\n" +
                        " 1) List - хранит упорядоченные элементы(могут быть одинаковые);\n" +
                        "    Имеет такие реализации как LinkedList, ArrayList и Vector.\n" +
                        "    1.1) Vector синхронизирован, и по этому в одном потоке, он работает\n" +
                        "         медленней остальных реализаций.\n" +
                        "    1.2) ArrayList - его преимущество в навигации по коллекции.\n" +
                        "    1.3) LinkedList - Его преимущество в во вставке и удалении элементов\n" +
                        "         в коллекции.\n\n" +
                        " 2) Set - коллекции, которые не содержат повторяющихся элементов.\n" +
                        "    Основные реализации: HashSet, TreeSet, LinkedHashSet.\n" +
                        "    2.1) TreeSet - упорядочивает элементы по их значениям.\n" +
                        "    2.2) HashSet - упорядочивает элементы по их хэш ключах,\n" +
                        "         хотя на первый взляд может показаться что элементы\n" +
                        "         хранятся в случайном порядке.\n" +
                        "    2.3) LinkedHashSet - хранит элементы в порядке их добавления\n\n" +
                        " 3) Queue - интерфейс для реализации очереди в джава.\n" +
                        "    Основные реализации: LinkedList, PriorityQueue.\n" +
                        "    Очереди работают по принципу FIFO - first in first out.\n\n" +
                        " Map - интерфейс для реализации так называемой карты, где элементы хранятся\n" +
                        " с их ключами.\n" +
                        " Основные реализации: HashTable, HashMap, TreeMap, LinkedHashMap.\n" +
                        " 1) HashTable - синхронизированна, объявлена уставревшей.\n" +
                        " 2) HashMap - порядок елементов рассчитывается по хэш ключу.\n" +
                        " 3) TreeMap - элементы хранятся в отсортированном порядке.\n" +
                        " 4) LinkedHashMap - элементы хранятся в порядке вставки\n" +
                        " Ключи в Мар не могут быть одинаковыми!\n" +
                        " Синхронизировать не синхронизированные коллекции и карты\n" +
                        " можно посредством класса Collections.synchronizedMap(MyMap)\\ \n" +
                        " synchronizedList(MyList)."); //ответ 101
        answersList.add(" Отличие заключается в способе хранения данных. ArrayList хранит\n" +
                        " в виде массива, а LinkedList - в виде списка (двунаправленного).\n" +
                        " В ArrayList быстрее происходит сортировка, т.к. для ее выполнения\n" +
                        " данные списка копируются в массив (а копировать из массива ArrayList\n" +
                        " в массив для сортировки быстрее). При большом числе операций добавления\n" +
                        " и удаления LinkedList должен быть более удачным выбором, т.к. при этих\n" +
                        " операциях не приходится перемещать части массива. Если при добавлении\n" +
                        " в ArrayList превышается его объем, размер массива увеличивается,\n" +
                        " новая емкость рассчитывается по формуле (oldCapacity * 3) / 2 + 1,\n" +
                        " поэтому лучше указывать размер при создании или, если он не известен,\n" +
                        " использовать LinkedList (но это может быть существенно при слишком уж\n" +
                        " больших объемах данных)."); //ответ 102
        answersList.add(" Класс HashMap по функционалу очень похож на Hashtable. Главное отличие\n" +
                        " в том, что методы класса Hashtable синхронизированы, а HashMap - нет.\n" +
                        " Кроме этого класс HashMap в отличии от Hashtable разрешает использование\n" +
                        " null в качестве ключей и значений. Наличие синхронизации в Hashtable\n" +
                        " уменьшает производительность кода, использующего данный класс.\n" +
                        " Поэтому классы JCF (Java Collections Framework, появившийся в Java 2),\n" +
                        " в том числе и HashMap, несинхронизированы. Если синхронизация все же нужна,\n" +
                        " можно использовать методы класса Collections: Collections.synchronizedMap(map),\n" +
                        " Collections.synchronizedList(list) или Collections.synchronizedSet(set).\n" +
                        " Данные методы возвращают синхронизированный декоратор переданной коллекции.\n" +
                        " При этом все равно в случае итерирования по коллекции требуется ручная\n" +
                        " синхронизация. Начиная с Java 6 JCF был расширен специальными коллекциями,\n" +
                        " поддерживающими многопоточный доступ, такими как CopyOnWriteArrayList\n" +
                        " и ConcurrentHashMap."); //ответ 103
        answersList.add(" Методы класса Vector синхронизированы, в то время как ArrayList - нет."); //ответ 104
        answersList.add(" Для сравнения элементов коллекций используется метод equals() и hashcode();\n" +
                        " Эти методы унаследованы от класса Object:" +
                        " 1) Если наш пользовательский класс переопределяет equals(), то он должен\n" +
                        "    и переопределить hashcode().\n" +
                        " 2) Если два объекта эквивалентны, то и хэш коды этих объектов тоже должны\n" +
                        "    быть равны\n" +
                        " 3) Если поле не используется в equals(), то оно и не должно использоваться\n" +
                        "    в hashcode().\n"); //ответ 105
        answersList.add(" \"number)\" - означает номер цепочки иеархии.\n" +
                        " 1) Iterator<E>\n\n" +
                        " 2) Iterable<T> <- Collection<E>  <- List<E>\n" +
                        "                                  <- Set<E>            <- SortedSet<E> <- NavigableSet<E>\n\n" +
                        " 3) Map<K,V>    <- SortedMap<K,V> <- NavigableMap<K,V>"); //ответ 106
        answersList.add(" Коллекция (List и Set) представляет собой совокупность некоторых элементов\n" +
                        " (обычно экземпляров одного класса).Map -это совокупность пар \"ключ\"-\"значение\".\n" +
                        " Соответственно некоторые методы интерфейса Collection нельзя использовать в Map.\n" +
                        " Например, метод remove(Object o) в интерфейсе Collection предназначен для удаления\n" +
                        " элемента, тогда как такой же метод remove(Object key) в интерфейсе Map - удаляет элемент\n" +
                        " по заданному ключу."); //ответ 107
        answersList.add(" Итератор - объект, позволяющий перебирать элементы коллекции. Например foreach\n" +
                        " реализован с использованием итератора. Одним из ключевых методов интерфейса\n" +
                        " Collection является метод Iterator<E> iterator().\n" +
                        " Он возвращает итератор - то есть объект, реализующий интерфейс Iterator.\n" +
                        " Интерфейс Iterator имеет следующее определение:\n" +
                        " public interface Iterator<E>{\n" +
                        "     E next();\n" +
                        "     boolean hasNext();\n" +
                        "     void remove();\n" +
                        " }"); //ответ 108
        answersList.add(" Все коллекции из java.util реализуют интерфейс Collection, который,\n" +
                        " в свою очередь, расширяет интерфейс Iterable. В интерфейсе Iterable\n" +
                        " описан только один метод:\n\n" +
                        " Iterator iterator();\n\n" +
                        " Он возвращает Iterator, т.е. объект, который поочерёдно возвращает\n" +
                        " все элементы коллекции."); //ответ 109
        answersList.add(" public static void main(String...args){\n" +
                        "     Set<String> set = new HashSet<>();\n" +
                        "     set.add(\"A\");\n" +
                        "     set.add(\"B\");\n" +
                        "     //Преобразование.\n" +
                        "     List<String> list = new ArrayList<>(set);\n" +
                        " }");  //ответ 110
        answersList.add(" public static void main(String...args){\n" +
                        "     List<String> list = new ArrayList<>()\n;" +
                        "     list.add(\"A\");\n" +
                        "     list.add(\"B\");\n" +
                        "     //Преобразование.\n" +
                        "     Set<String> set = new HashSet<>(list);\n" +
                        " }"); //ответ 111
        answersList.add(" Использовать метод keySet(), который возвращает множество (Set<K>) ключей."); //ответ 112
        answersList.add(" Использовать метод values(), который возвращает коллекцию (Collection<V>) значений."); //ответ 113
        answersList.add(" Использовать метод entrySet(), который возвращает множество (Set&lt;Map.Entry<K,V>)\n" +
                        " пар \"ключ\"-\"значение\"."); //ответ 114
        answersList.add(" Естественное упорядочивание (natural ordering) отражается при итерации по коллекции\n" +
                        " ключей или значений хэш-таблицы (возвращаемых методами keySet(), values() и entrySet())."); //ответ 115
        answersList.add(" public static void main(String...args) {\n" +
                        "     List<String> list = new ArrayList<>();\n" +
                        "     list.add(\"A\");\n" +
                        "     list.add(\"B\");\n" +
                        "     String[] strArray = list.toArray(new String[list.size()]);\n" +
                        "     // Либо\n" +
                        "     Object[] objArray = list.toArray();\n" +
                        " }");  //ответ 116
        answersList.add(" Симметрическая разность двух коллекций - это множество элементов, одновременно\n" +
                        " не принадлежащих обоим исходным коллекциям:\n\n" +
                        " public static <T> Collection<T> symmetricDifference(Collection<T> a, Collection<T> b){\n" +
                        "     // Создаем новую коллекцию, чтобы не изменять исходные.\n" +
                        "     Collection<T> intersection = new ArrayList<>(a);\n" +
                        "     // Получаем пересечение коллекций\n" +
                        "     intersection.retainAll(b);\n" +
                        "     Collection<T> result = new ArrayList<>(a);\n" +
                        "     // Обьединяем коллекции\n" +
                        "     result.addAll(b);\n" +
                        "     // Удаляем элементы, расположенные в обоих коллекциях\n" +
                        "     result.removeAll(intersection);\n\n" +
                        "     return result;\n" +
                        " }\n\n" +
                        " public static void main(String[] args) {\n" +
                        "     List<String> a = new ArrayList<>(Arrays.asList(\"1\", \"2\",\"3\",\"4\",\"5\"));\n" +
                        "     Collection<String> c = symmetricDifference(a,b);\n" +
                        "     System.out.println(\"Collection a: \" + Arrays.toString(a.toArray())); // Collection a: [1, 2, 3, 4, 5]\n" +
                        "     System.out.println(\"Collection b: \" + Arrays.toString(b.toArray())); // Collection b: [3, 4, 5, 6, 7]\n" +
                        "     System.out.println(\"Collection c: \" + Arrays.toString(c.toArray())); // Collection b: [1, 2, 6, 7]\n" +
                        " }"); //ответ 117
        answersList.add(" Оба интерфейса предназначены для обхода коллекций. Интерфейс Iterator\n" +
                        " был введен несколько позднее в Java Collections Framework и его использование\n" +
                        " предпочтительнее. Основные различия Iterator по сравнению с Enumeration:\n" +
                        " 1) наличие метода remove() для удаления элемента из коллекции при обходе;\n" +
                        " 2) исправлены имена методов для повышения читаемости кода.\n"); //ответ 118
        answersList.add(" Интерфейс Iterable имеет только один метод - iterator(), который\n" +
                        " возвращает итератор коллекции для её обхода."); //ответ 119
        answersList.add(" Экземпляры классов, реализующих интерфейс Iterable, могут использоваться\n" +
                        " в конструкции foreach."); //ответ 120
        answersList.add(" ListIterator расширяет интерфейс Iterator, позволяя клиенту осуществлять\n" +
                        " обход коллекции в обоих направлениях, изменять коллекцию и получать текущую\n" +
                        " позицию итератора. При этом важно помнить, что ListIterator не указывает\n" +
                        " на конкретный элемент, а его текущая позиция располагается между элементами,\n" +
                        " которые возвращают методы previous() и next(). Таким образом, модификация\n" +
                        " коллекции осуществляется для последнего элемента, который был возвращен\n" +
                        " методами previous() и next()."); //ответ 121
        answersList.add(" Если итератор указывает на последний элемент коллекции, то возникнет\n" +
                        " исключение NoSuchElementException, иначе будет возвращен следующий элемент."); //ответ 122
        answersList.add(" Нет, hasNext() осуществляет только проверку наличия следующего элемента."); //ответ 123
        answersList.add(" Вызов метода iterator.remove() возможен только после вызова метода\n" +
                        " iterator.next() хотя бы раз, иначе появится исключение\n" +
                        " IllegalStateException(). Если iterator.next() был вызван прежде,\n" +
                        " то iterator.remove() удалит элемент, на который указывает итератор."); //ответ 124
        answersList.add(" Итератор не изменится, но при следующем вызове его методов возникнет\n" +
                        " исключение ConcurrentModificationException."); //ответ 125
        answersList.add(" Обе структуры данных предназначены для хранения коллекции элементов,\n" +
                        " в том числе дупликатов и null. Они основаны на использовании массивов,\n" +
                        " динамически расширяющихся при необходимости. Класс Vector был введен\n" +
                        " в JDK 1.0 и не является частью Java Collection Framework. Методы класса\n" +
                        " Vector синхронизированы, что обеспечивает потокобезопасность, но это\n" +
                        " приводит к снижению производительности, поэтому и был введен класс\n" +
                        " ArrayList, методы которого не синхронизированы."); //ответ 126
        answersList.add(" Размер массива elementData представляет собой вместимость (capacity)\n" +
                        " ArrayList, которая всегда больше переменной size - реального количества\n" +
                        " хранимых элементов. С добавлением новых элементов вместимость автоматически\n" +
                        " возрастает при необходимости."); //ответ 127
        answersList.add(" Двухсвязный список: каждый элемент LinkedList хранит ссылку на предыдущий\n" +
                        " и следующий элементы."); //ответ 128
        answersList.add(" O(N). Время поиска элемента линейно пропорционально количеству элементов с списке."); //ответ 129
        answersList.add(" O(N). Время поиска элемента линейно пропорционально количеству элементов с списке."); //ответ 130
        answersList.add(" O(N). Здесь стоит заметить, что добавление элемента в конец списка с помощью\n" +
                        " методом add(value), addLast(value) и добавление в начало списка с помощью\n" +
                        " addFirst(value) выполняется за время O(1). O(N) - будет при добавление элемента\n" +
                        " в отсортированный список, а также при добавлении элемента с помощью метода\n" +
                        " add(index, value)."); //ответ 131
        answersList.add(" O(N) - будет при добавление элемента в отсортированный список, а также при\n" +
                        " добавлении элемента с помощью метода add(index, value)."); //ответ 132
        answersList.add(" Если в массиве достаточно места для размещения нового элемента,\n" +
                        " то дополнительное место в памяти не выделяется. Иначе происходит\n" +
                        " создание нового массива с размером:\n\n" +
                        " int oldCapacity = elementData.length;\n" +
                        " int newCapacity = oldCapacity + (oldCapacity >> 1);\n\n" +
                        " Другими словами, создается новый массив, размер которого вычисляется как\n" +
                        " умножение старого размера на 1.5 (это верно для JDK 1.7, в более ранних версиях\n" +
                        " вычисления отличаются)."); //ответ 133
        answersList.add(" Создается один новый экземпляр вложенного класса Node."); //ответ 134
        answersList.add(" Каждый элемент LinkedList хранит ссылку на предыдущий элемент, следующий элемент\n" +
                        " и ссылку на данные. Для x32 систем каждая ссылка занимает 32 бита (4 байта).\n" +
                        " Сам объект типа Node занимает приблизительно 8 байт. Размер каждого объекта\n" +
                        " в Java кратен 8, соответственно получаем 24 байта. Примитив типа byte занимает\n" +
                        " 1 байт памяти, но в списке примитивы упаковываются, соответственно получаем еще\n" +
                        " 8 байт. Таким образом, в x32 JVM около 32 байтоввыделяется для хранения одного\n" +
                        " значения типа byte в LinkedList. Для 64-битной JVM каждая ссылка занимает 64 бита\n" +
                        " (8 байт). Вычисления аналогичны."); //ответ 135
        answersList.add(" ArrayList основан на массиве. Каждый элемент массива хранит примитивный тип данных\n" +
                        " - byte, размер которого 1 байт."); //ответ 136
        answersList.add(" 1) Для ArrayList:" +
                        "    1.1) проверка массива на вместимость. Если вместимости недостаточно, то увеличение\n" +
                        "         размера массива и копирование всех элементов в новый массив (O(N));\n" +
                        "    1.2) копирование всех элементов, расположенных правее от позиции вставки,\n" +
                        "         на одну позицию вправо (O(N/2));\n" +
                        "    1.3) вставка элемента (O(1)).\n" +
                        " 2) Для LinkedList:\n" +
                        "    2.1) поиск позиции вставки (O(N/2));\n" +
                        "    2.2) вставка элемента (O(1)).\n" +
                        " В худшем случае вставка в середину списка эффективнее для LinkedList.\n" +
                        " В остальных - скорее всего, для ArrayList, поскольку копирование элементов\n" +
                        " осуществляется за счет системного метода System.arraycopy()."); //ответ 137
        answersList.add(" Использовать обратный итератор. Для этого в LinkedList есть метод\n" +
                        " descendingIterator()."); //ответ 138
        answersList.add(" List<Integer> sourceList = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9));\n" +
                        " List<Integer> subList = sourceList.subList(3, sourceList.size() - 3); // 4, 5, 6"); //ответ 139
        answersList.add(" Да, могут. Метод hashCode() не гарантирует уникальность возвращаемого значения."); //ответ 140
        answersList.add(" Да, могут. Для этого в классе этих объектов должен быть переопределен метод equals().\n" +
                        " Если используется метод Object.equals(), то для двух ссылок x и y метод вернет true\n" +
                        " тогда и только тогда, когда обе ссылки указывают на один и тот же объект\n" +
                        " (т.е. x == y возвращает true)."); //ответ 141
        answersList.add(" Нет, не может. Метод equals() должен гарантировать свойство рефлексивности:\n" +
                        " для любых ненулевых ссылок метод x.equals(x) должен возвращать true"); //ответ 142
        answersList.add(" Множитель создает зависимость значения хэш-кода от очередности обработки полей,\n" +
                        " а это дает гораздо лучшую хэш-функцию."); //ответ 143
        answersList.add(" HashSet использует HashMap для хранения элементов (в качестве ключа используется\n" +
                        " сам объект). При добавлении элемента в HashMap вычисляется хэшкод и позиция в массиве,\n" +
                        " куда будет вставлен новый элемент. У всех экземпляров класса Point одинаковый хэшкод,\n" +
                        " что приводит в вырождению хэш-таблицы в список. При возникновении коллизии\n" +
                        " осуществляется проверка на наличие уже такого элемента в текущем списке:\n\n" +
                        " e.hash = hash && ((k = e.key) = key || key.equals(k))\n\n" +
                        " Если элемент найден, то его значение перезаписывается. В нашем случае для разных\n" +
                        " объектов метод equals() будет возвращать false. Соответственно новый элемент будет\n" +
                        " добавлен в HashSet. Извлечение элемента также будет осуществляться успешно.\n" +
                        " Но производительность такого кода будет низкой и преимущества хэш-таблиц\n" +
                        " использоваться не будут."); //ответ 144
        answersList.add(" Метод equals() должен обеспечивать:\n" +
                        " 1) симметричность (для любых ненулевых ссылок x и y метод x.equals(y) должен возвращать\n" +
                        "    true тогда и только тогда, когда y.equals(x) возвращает true);\n" +
                        " 2) рефлексивность (для любых ненулевых ссылок x метод x.equals(x) должен возвращать\n" +
                        "    true.);\n" +
                        " 3) транзитивность (для любых ненулевых ссылок x, y и z, если x.equals(y) возвращает\n" +
                        "    true и y.equals(z)возвращает true, тогда и x.equals(z) должен возвращать true).\n" +
                        " Также есть ещё два свойства: постоянство и неравенство null."); //ответ 145
        answersList.add(" Строго говоря нельзя, поскольку метод hashCode() не гарантирует уникальность значения\n" +
                        " для каждого объекта. Однако для сравнения экземпляров класса Object такой код допустим,\n" +
                        " т.к. метод hashCode() в классе Object возвращает уникальные значения для разных\n" +
                        " объектов (вычисления основаны на использовании адреса объекта в памяти)."); //ответ 146
        answersList.add(" Оператор instanceof сравнивает объект и указанный тип. Его можно использовать\n" +
                        " для проверки является ли данный объект экземпляром некоторого класса, либо экземпляром\n" +
                        " его дочернего класса, либо экземпляром класса, который реализует указанный интерфейс.\n" +
                        " getClass() = ... проверяет два типа на идентичность.\n" +
                        " Для корректной реализации контракта метода equals() необходимо использовать точное\n" +
                        " сравнение с помощью getClass()."); //ответ 147
        answersList.add(" Реализовать можно, но данный метод не переопределяет метод equals() класса Object,\n" +
                        " а перегружает его."); //ответ 148
        answersList.add(" Да, будет. Но тогда хэш-таблица вырождается в связный список и теряет свои преимущества."); //ответ 149
        answersList.add(" Класс Hashtable был введен в JDK 1.0 и не является частью Java Collection Framework.\n" +
                        " Методы класса Hashtable синхронизированы, что обеспечивает потокобезопасность,\n" +
                        " но это приводит к снижению производительности, поэтому и был введен класс HashMap,\n" +
                        " методы которого не синхронизированы. Помимо этого класс HashMap обладает некоторыми\n" +
                        " другими отличиями: например, позволяет хранить один null ключ и множество null значений."); //ответ 150
        answersList.add(" Класс HashMap реализован с использованием метода цепочек, т.е. каждой ячейке массива\n" +
                        " соответствует свой связный список и при возникновении коллизии осуществляется\n" +
                        " добавление нового элемента в этот список. Для метода цепочек коэффициент заполнения\n" +
                        " может быть больше 1, с увеличением числа элементов производительность убывает\n" +
                        " линейно. Такие таблицы удобно использовать, если заранее неизвестно количество\n" +
                        " хранимых элементов, либо их может быть достаточно много, что приводит к большим\n" +
                        " значениям коэффициента заполнения. Среди методов открытой реализации различают:\n" +
                        " 1) линейное пробирование;\n" +
                        " 2) квадратичное пробирование;\n" +
                        " 3) двойное хеширование.\n" +
                        " Основные недостатки структур с методом открытой адресации:\n" +
                        " 1) Количество элементов в таблице не может превышать размера массива.\n" +
                        "    По мере увеличения числа элементов в таблице и повышения коэффициента\n" +
                        "    заполнения (load factor) производительность структуры резко падает,\n" +
                        "    поэтому необходимо проводить перехеширование.\n" +
                        " 2) Сложно организовать удаление элемента.\n" +
                        " 3) Также первые два метода открытой адресации приводят к проблеме первичной\n" +
                        "    и вторичной группировок.\n" +
                        " Основное преимущество хэш-таблицы с открытой адресацией - это отсутствие затрат\n" +
                        " на создание и хранение объектов списка. Также проще организовать\n" +
                        " сериализацию/десериализацию объекта."); //ответ 151
        answersList.add(" Возможно, я неправильно понял этот вопрос. За переходы по ссылке в данном ответе\n" +
                        " я считаю вызовы методов:\n\n" +
                        " public V get(Object key){\n" +
                        "    if(key == null))\n" +
                        "       return getForNullKey();\n" +
                        "    Entry<K,V> entry = getEntry(key);\n\n" +
                        "    return null == entry ? null : entry.getValue();\n" +
                        " }\n\n" +
                        " Рассмотрим первый случай, когда ключ равен null: выполняем метод getForNullKey().\n\n" +
                        " private V getForNullKey() {\n" +
                        "    if(size ==0) {\n" +
                        "       return null;\n" +
                        "    }\n" +
                        "    for(Entry<K,V> e = table[0]; e != null; e = e.next) {\n" +
                        "        if(e.key == null)\n" +
                        "           return e.value;\n" +
                        "    }\n" +
                        "    return null;\n" +
                        " }\n\n" +
                        " В цикле foreach проходимся по списку значений для ключа и возвращаем\n" +
                        " нужное значение. Таким образом, получаем 1 переход.\n" +
                        " Второй случай: ключ не равен null. Выполняем метод getEntry(key).\n\n" +
                        " final Entry<K,V> getEntry(Object key) {\n" +
                        "     if(size == 0) {\n" +
                        "        return null;\n" +
                        "     }\n\n" +
                        "     int hash = (key == null) ? 0: hash(key);\n" +
                        "     for(Entry<K,V> e = table[indexFor(hash, table.length)]; e != null; e = e.next) {\n" +
                        "         Object k;\n" +
                        "         if(e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k))))\n" +
                        "            return e;\n" +
                        "     }\n" +
                        "     return null;\n" +
                        " }\n\n" +
                        " Вычисляется хэш-код ключа (метод hash(key)), затем определяется индекс ячейки массива,\n" +
                        " в которой будем искать значение (метод indexFor(hash, table.length)).\n" +
                        " После того, как нашли нужную пару \"ключ-значение\" возвращаем значение\n" +
                        " (метод entry.getValue()). Таким образом, получаем 4 перехода."); //ответ 152
        answersList.add(" Один новый объект статического вложенного класса Entry<K,V>."); //ответ 153
        answersList.add(" По значению hashCode вычисляется индекс ячейки массива, в список которой будет\n" +
                        " происходить добавление элемента. Перед добавлением осуществляется проверка на\n" +
                        " наличие уже элементов в этой ячейке. Если элементов нет, то происходит\n" +
                        " добавление. Если возникает коллизия, то итеративно осуществляется обход списка\n" +
                        " в поисках элемента с таким же ключом и хэш-кодом. Если такой элемент найден,\n" +
                        " то его значение перезаписывается, а старое - возвращается. Поскольку в условии\n" +
                        " сказано, что добавляемые ключи - разные, то второй элемент будет добавлен в начало\n" +
                        " списка."); //ответ 154
        answersList.add(" Это возможно в случае, если метод, определяющий номер ячейки массива по hashCode будет\n" +
                        " возвращать одинаковое значение."); //ответ 155
        answersList.add(" O(N). Худший случай - это поиск ключа в таблице, вырожденной в список, перебор ключей\n" +
                        " которой занимает линейно пропорциональное время количеству хранимых элементов."); //ответ 156
        answersList.add(" O(N). Аналогичные рассуждения, что и для предыдущего вопроса."); //ответ 157
        answersList.add(" int initialCapacity - исходный размер HashMap (количество корзин в хэш-таблице\n" +
                        " в момент её создания), по умолчанию имеет значение 16. float loadFactor - коэффициент\n" +
                        " заполнения HashMap. Равен отношению числа хранимых элементов в таблице к её размеру.\n" +
                        " loadFactor - является мерой заполнения таблицы элементами, при превышении количества\n" +
                        " хранимых таблицей значений , происходит автоматическое перехеширование. Значение по\n" +
                        " умолчанию 0.75 является хорошим компромиссом между временем доступа и объемом хранимых\n" +
                        " данных."); //ответ 158
        answersList.add(" IdentityHashMap - это структура данных, реализующая интерфейс Map, но использующая\n" +
                        " сравнение ссылок вместо метода equals() при сравнении ключей (значений).\n" +
                        " Другими словами, в IdentityHashMap два ключа k1 и k2 будут рассматриваться\n" +
                        " равными, если выполняется условие k1 == k2.\n" +
                        " IdentityHashMap не использует метод hashCode(), вместо которого применяется метод\n" +
                        " System.identityHashCode(Object). Другое отличие (как следствие) заключается в более\n" +
                        " высокой производительности IdentityHashMap по сравнению с HashMap, если последний\n" +
                        " хранит объекты с дорогостоящими методами equals() и hashCode(). Одним из основных\n" +
                        " требований к использованию HashMap является неизменяемость ключа, однако\n" +
                        " это требование не распространяется на IdentityHashMap, который не использует\n" +
                        " методы equals() и hashCode(). Согласно документации, такая структура данных\n" +
                        " может применяться для реализации сериализации/клонирования. Для выполнения подобных\n" +
                        " алгоритмов программе необходимо обслуживать таблицу со всеми ссылками на объекты,\n" +
                        " которые уже были обработаны. Такая таблица не должна рассматривать уникальные объекты\n" +
                        " как равные, даже если метод equals() возвращает true."); //ответ 159
        answersList.add(" Перед рассмотрением WeakHashMap кратко напомню, что такое WeakReference.\n" +
                        " В Java существует 4 типа ссылок: сильные (strong reference), мягкие\n" +
                        " (SoftReference), слабые (WeakReference) и фантомные (PhantomReference).\n" +
                        " Особенности каждого типа ссылок связаны с работой Garbage Collector.\n" +
                        " Если объект можно достичь только с помощью цепочки WeakReference\n" +
                        " (то есть на него не ссылаются сильные и мягкие ссылки), то данный объект\n" +
                        " будет отмечен для удаления. WeakHashMap - это структура данных, реализующая\n" +
                        " интерфейс Map и основанная на использовании WeakReference для хранения ключей.\n" +
                        " Таким образом, пара \"ключ-значение\" будет удалена из WeakHashMap, если\n" +
                        " на объект-ключ более не имеется сильных ссылок. В качестве примера использования\n" +
                        " такой структуры данных можно привести следующую ситуацию: допустим имеются\n" +
                        " объекты, которые необходимо расширить дополнительной информацией, при этом\n" +
                        " изменение класса этих объектов нежелательно либо невозможно. В этом случае\n" +
                        " добавляем каждый объект в WeakHashMap в качестве ключа, а в качестве значения\n" +
                        " - нужную информацию. Таким образом, пока на объект имеется сильная ссылка\n" +
                        " (либо мягкая), можно проверять хэш-таблицу и извлекать информацию.\n" +
                        " Как только объект будет удален, то WeakReference для этого ключа будет помещен\n" +
                        " в ReferenceQueue и затем соответствующая запись для этой слабой ссылки будет\n" +
                        " удалена из WeakHashMap."); //ответ 160
        answersList.add(" SoftHashMap представлена в стронних библиотеках, например, в Apache Commons.\n"); //ответ 161
        answersList.add(" PhantomReference при вызове метода get() возвращает всегда null, поэтому,\n" +
                        " я думаю, создание PhantomHashMap просто невозможно. Плюс назначение такой\n" +
                        " структуры данных тяжело представить."); //ответ 162
        answersList.add(" Set<Object> keySet = new HashSet<>(map.keySet());"); //ответ 163
        answersList.add(" Map<K,V> map = new HashMap<>(set.size());\n" +
                        " for(Map.Entry<K,V> entry : set) {\n" +
                        "     map.put(entry.getKey(), entry.getValue());\n" +
                        " }"); //ответ 164
        answersList.add(" Согласно документации Deque (\"дек\", Double Ended Queue) - это линейная\n" +
                        " коллекция, поддерживающая вставку/извлечение элементов с обоих концов.\n" +
                        " Помимо этого реализации интерфейса Deque могут строится по принципу FIFO,\n" +
                        " либо LIFO.\n" +
                        " Queue - это очередь, обычно (но необязательно) строится по принципу FIFO\n" +
                        " (First-In-First-Out) - соответственно извлечение элемента осуществляется\n" +
                        " с начала очереди, вставка элемента - в конец очереди. Этот принцип нарушает,\n" +
                        " к примеру, приоритетная очередь (PriorityQueue), использующая переданный\n" +
                        " comparator при вставке нового элемента, либо расстановка элементов\n" +
                        " осуществляется согласно естественному упорядочиванию (natural ordering).\n" +
                        " Deque расширяет Queue. Реализации и Deque, и Queue обычно не переопределяют\n" +
                        " методы equals() и hashCode(), основанные на сравнении хранящихся элементов.\n" +
                        " Вместо этого используются унаследованные методы класса Object, основанные на\n" +
                        " сравнении ссылок."); //ответ 165
        answersList.add(" Deque расширяет Queue."); //ответ 166
        answersList.add(" LinkedList позволяет добавлять элементы в начало и конец списка за константное\n" +
                        " время, что хорошо подходит для реализации интерфейса Deque\n" +
                        " (в отличие, например, от ArrayList)."); //ответ 167
        answersList.add(" java.util.Arrays - класс, содержащий статические методы для работы с массивами,\n" +
                        " таких как, например, поиск по массиву и его сортировка.\n" +
                        " java.lang.reflect.Array - класс для работы с массивами при использовании рефлексии.\n" +
                        " Рефлексия - это механизм, позволяющий исследовать данные о программе во время\n" +
                        " её выполнения."); //ответ 168
        answersList.add(" Класс java.util.Collections содержит исключительно статические методы для работы\n" +
                        " с коллекциями. В них входят методы, реализующие полиморфные алгоритмы\n" +
                        " (такие алгоритмы, использование которых возможно с разными видами структур данных),\n" +
                        " \"оболочки\", возвращающие новую коллекцию с инкапсулированной указанной структурой\n" +
                        " данных и некоторые другие методы. java.util.Collection - это корневой интерфейс Java\n" +
                        " Collections Framework. Этот интерфейс в основном применяется там, где требуется\n" +
                        " высокий уровень абстракции, например, в классе java.util.Collections."); //ответ 169
        answersList.add(" List<String> stringList = new ArrayList<>();\n" +
                        " stringList.add(\"1\");\n" +
                        " stringList.add(\"2\");\n" +
                        " stringList.add(\"3\");\n\n" +
                        " Iterator<String> listIterator = stringList.iterator();\n" +
                        " stringList.remove(\"2\");\n" +
                        " while(listIterator.hasNext()) {\n" +
                        "     System.out.println(listIterator.next());\n" +
                        " }"); //ответ 170
        answersList.add(" Fail-fast поведение означает, что при возникновении ошибки или состояния,\n" +
                        " которое может привести к ошибке, система немедленно прекращает дальнейшую\n" +
                        " работу и уведомляет об этом. В Java Collections API итераторы могут\n" +
                        " использовать либо fail-fast, либо fail-safe поведение, либо быть weakly\n" +
                        " consistent. Итератор с fail-fast поведением выбросит исключение\n" +
                        " ConcurrentModificationException, если после его создания была произведена\n" +
                        " модификация коллекции, т.е. добавлен или удален элемент (без использования\n" +
                        " метода remove() итератора). Реализация такого поведения осуществляется\n" +
                        " за счет подсчета количества модификаций коллекции (modification count):\n" +
                        " 1) при изменении коллекции (удаление/добавление элемента) счетчик\n" +
                        "    увеличивается;\n" +
                        " 2) при создании итератора ему передается текущее значение счетчика;\n" +
                        " 3) при каждом обращении к итератору сохраненное значение счетчика\n" +
                        "    сравнивается с текущим, и, если они не совпадают, возникает исключение.\n" +
                        " Использование fail-fast подхода позволяет избежать недетерминированного\n" +
                        " поведения программы в течение времени. Также стоит отметить, что fail-fast\n" +
                        " поведение не может быть абсолютно гарантировано."); //ответ 171
        answersList.add(" EnumSet - это одна из разновидностей реализации интерфейса Set для использования\n" +
                        " с перечислениями (Enum). EnumSet использует массив битов для хранения значений\n" +
                        " (bit vector), что позволяет получить высокую компактность и эффективность.\n" +
                        " В структуре данных хранятся объекты только одного типа Enum, который указывается\n" +
                        " при создании экземпляра EnumSet. Все основные операции выполняются за константное\n" +
                        " время (O(1)) и в основном несколько быстрее (хотя и негарантированно), чем их\n" +
                        " аналоги в реализации HashSet. Пакетные операции (bulk operations, например,\n" +
                        " containsAll()  и retainAll()) выполняются очень быстро, если их аргументом\n" +
                        " является экземпляр типаEnum. Помимо этого класс EnumSet предоставляет множество\n" +
                        " статических методов инициализации для упрощенного и удобного создания экземпляров.\n" +
                        " Итерация по EnumSet осуществляется согласно порядку объявления элементов\n" +
                        " перечисления."); //ответ 172
        answersList.add(" Рекомендуется использовать интерфейс Deque (\"дек\", Double Ended Queue) и его\n" +
                        " реализации. Например:\n\n" +
                        " Deque<Integer> stack = new ArrayDeque<Integer>();\n\n" +
                        " Стек - это структура данных, построенная на принципе LIFO (Last-In-First-Out,\n" +
                        " либо по-другому FILO). Каждое новое значение добавляется на \"вершину\" стека,\n" +
                        " а извлекается последний добавленный элемент (с \"вершины\" стека). При извлечении\n" +
                        " элемента он удаляется из структуры данных. Класс Stack появился в JDK 1.0\n" +
                        " и расширяет класс Vector, наследуя его функционал, что несколько нарушает понятие\n" +
                        " стека (например, класс Vector предоставляет возможность обращаться к любому\n" +
                        " элементу по индексу). Также использование Deque позволяет следовать принципу\n" +
                        " программирования на уровне интерфейсов, а не конкретных реализаций, что облегчает\n" +
                        " дальнейшую поддержку разрабатываемого класса и повышает его гибкость, позволяя при\n" +
                        " необходимости менять реализацию дека на нужную."); //ответ 173
        answersList.add(" FIFO - First-In-First-Out (первый пришел, первым ушел). По этому принципу обычно\n" +
                        " построена такая структура данных как очередь (java.util.Queue)."); //ответ 174
        answersList.add(" FILO - First-In-Last-Out (первый пришел, последним ушел). По этому принципу\n" +
                        " построена такая структура данных как стек (java.util.Stack)."); //175
        answersList.add(" List fixedList = Arrays.asList(\"1\", \"2\", \"3\");\n" +
                        " Iterator<String> listIterator = fixedList.iterator();\n" +
                        " while(iterator.hasNext()) {\n" +
                        "     String currentElement = iterator.next();\n" +
                        "     if(\"2\".equals(currentElement)) {\n" +
                        "        iterator.remove();\n" +
                        "     }\n" +
                        " }\n\n" +
                        " В данном примере возникнет исключение UnsupportedOperationException, поскольку\n" +
                        " метод asList() возвращает список фиксированной длины, т.е. удаление/добавление\n" +
                        " элементов в такой список не поддерживается."); //ответ 176
        answersList.add(" Это связано с ограничениями использования generic types (обобщенных типов).\n" +
                        " ArrayList<ArrayList> не является подтипом ArrayList<List>, соответственно\n" +
                        " использование такой записи запрещено."); //ответ 177
        answersList.add(" Реализация LinkedHashMap отличается от HashMap поддержкой двухсвязанного списка,\n" +
                        " определяющего порядок итерации по элементам структуры данных. По умолчанию элементы\n" +
                        " списка упорядочены согласно их порядку добавления в LinkedHashMap (insertion-order).\n" +
                        " Однако порядок итерации можно изменить, установив параметр конструктора accessOrder\n" +
                        " в значение true. В этом случае доступ осуществляется по порядку последнего обращения\n" +
                        " к элементу (access-order). Это означает, что при вызове методов get() или put() элемент,\n" +
                        " к которому обращаемся, перемещается в конец списка. При добавлении элемента, который\n" +
                        " уже присутствует в LinkedHashMap (т.е. с одинаковым ключом), порядок итерации\n" +
                        " по элементам не изменяется."); //ответ 178
        answersList.add(" Реализация LinkedHashSet отличается от HashSet поддержкой двухсвязанного списка,\n" +
                        " определяющего порядок итерации по элементам структуры данных. Элементы списка\n" +
                        " упорядочены согласно их порядку добавления в LinkedHashSet (insertion-order).\n" +
                        " При добавлении элемента, который уже присутствует в LinkedHashSet\n" +
                        " (т.е. с одинаковым ключом), порядок итерации по элементам не изменяется."); //ответ 179
        answersList.add(" Необходимо использовать LRU-алгоритм (Least Recently Used algorithm)\n" +
                        " и LinkedHashMap с access-order. В этом случае при обращении к элементу\n" +
                        " он будет перемещаться в конец списка, а наименее используемые элементы\n" +
                        " будут постепенно группироваться в начале списка.\n" +
                        " Для этого в стандартной реализации LinkedHashMap (source) есть метод\n" +
                        " removeEldestEntries(), который возвращает true, если текущий объект\n" +
                        " LinkedHashMap должен удалить наименее используемый элемент из коллекции.\n" +
                        " Метод вызывается при использовании методов put() и putAll():\n\n" +
                        " void addEntry(int hash, K key, V value, int bucketIndex) {\n" +
                        "     createEntry(hash, key, value, bucketIndex);\n\n" +
                        "     // Remove eldest entry if instructed, else grow capacity if appropriate\n" +
                        "     Entry<K,V> eldest = header.after;\n" +
                        "     if(removeEldestEntry(eldest)) {\n" +
                        "        removeEntryForKey(eldest.key);\n" +
                        "     } else {\n" +
                        "         if(size >= threshold)\n" +
                        "            resize(2*table.length);\n" +
                        "     }\n" +
                        " }\n\n" +
                        " Простой пример реализации кэша с очисткой старых значений при превышении\n" +
                        " указанного порога:\n\n" +
                        " public class LRUCache<K,V> extends LinkedHashMap<K,V> {\n" +
                        "     private static final int MAX_ENTRIES = 10;\n\n" +
                        "     public LRUCache(int initialCapacity) {\n" +
                        "         // Изменяем порядок итерации на access order.\n" +
                        "         super(initialCapacity, 0.85f, true);\n" +
                        "     }\n\n" +
                        "     @Override\n" +
                        "     protected boolean removeEldestEntry(Map.Entry<K,V> eldest) {\n" +
                        "         return size() > MAX_ENTRIES;\n" +
                        "     }\n" +
                        " }\n\n" +
                        " Стоит заметить, что LinkedHashMap не позволяет полностью реализовать\n" +
                        " LRU-алгоритм, поскольку при вставке уже имеющегося в коллекции элемента\n" +
                        " порядок итерации не меняется. "); //ответ 180
        answersList.add(" PriorityQueue - это структура данных, располагающая элементы в порядке\n" +
                        " натурального упорядочивания, либо используя переданный конструктору\n" +
                        " Comparator. Используя PriorityQueue, можно, например, реализовать\n" +
                        " алгоритм Дейкстры для поиска кратчайшего пути от одной вершины графа\n" +
                        " к другой. Либо применять для хранения объектов согласно их приоритету:\n" +
                        " например, сортировка пациентов врача - экстренные пациенты перемещаются\n" +
                        " в начало очереди, менее срочные пациенты - ближе к концу очереди.\n"); //ответ 181
        answersList.add(" Interface Comparable задает свойство сравнения объекту реализующему его.\n" +
                        " То есть делает объект сравнимым (по правилам разработчика).\n" +
                        " Interface Comparator позволяет создавать объекты, которые будут управлять\n" +
                        " процессом сравнения (например при сортировках)."); //ответ 182

        //4) JAVA 8
        answersList.add(" В Java 8 было добавлено много функций, наиболее значимые из них упомянуты\n" +
                        " ниже:\n" +
                        " 1) Полноценная поддержка лямбда-выражений, которая добавляет функциональные\n" +
                        "    возможности обработки данных для Java.\n" +
                        " 2) Ключевое слово default в интерфейсах для поддержки функциональности\n" +
                        "    по умолчанию(интерфейс может иметь реализацию метода по умолчанию).\n" +
                        " 3) Ссылки на методы.\n" +
                        " 4) Функциональные интерфейсы (предикаты, поставщики и т. д.)\n" +
                        " 5) Потоки (stream) для работы с коллекциями\n" +
                        " 6) Новое API для работы с датами\n" +
                        " 7) Nashorn движок JavaScript, разрабатываемый полностью на Java компанией Oracle."); //ответ 183
        answersList.add(" Следующий код сортирует список строк с помощью лямбда-выражения Java 8:\n\n" +
                        " //sort using java 8\n" +
                        " private void sortUsingJava8(List<String> names) {\n" +
                        "   Collections.sort(names, (s1, s2) -> s1.compareTo(s2));\n" +
                        " }"); //ответ 184
        answersList.add(" Лямбда выражение имеет следующую структуру:\n\n" +
                        " (method params) -> {lambda expression body}\n\n" +
                        " где\n" +
                        " 1) method params - список входящих параметров, разделенных запятой(в случаи если\n" +
                        "    параметров больше одного заключаются в скобки).\n" +
                        " 2) оператор \"->\" - служит разделителем между списком параметров нашего метода\n" +
                        "    и телом, в котором происходит его реализация.\n" +
                        " 3) lambda expression body - тело метода, состоящее из одного выражения или\n" +
                        "    нескольких, заключенных в фигурные скобки."); //ответ 185
        answersList.add(" Лямбда-выражения имеют доступ к переменным области видимости, в которой их\n" +
                        " определили. Но доступ возможен только при условии, что переменные являются\n" +
                        " effective final, то есть либо явно имеют модификатор final, либо не меняют\n" +
                        " своего значения после инициализации, если переменной присваивается значение\n" +
                        " во второй раз, лямбда-выражение вызывает ошибку компиляции."); //ответ 186
        answersList.add(" Ссылки на метод - компактные лямбда-выражения которые позволяют передавать\n" +
                        " ссылки на методы или конструкторы. Для этого нужно использовать ключевое\n" +
                        " слово \"::\".\n" +
                        " Ссылочные методы внедряют полезный синтаксис, чтобы ссылаться на существующие\n" +
                        " методы или конструкторы Java-классов или объектов (экземпляров). Совместно\n" +
                        " с лямбда-выражениями, ссылочные методы делают языковые конструкции компактными\n" +
                        " и лаконичными, делая его шаблонным."); //ответ 187
        answersList.add(" Существует четыре вида ссылок на методы:\n" +
                        " 1) Ссылка на статический метод(ContainingClass::staticMethodName)\n" +
                        " 2) Ссылка на метод конкретного объекта(ContainingObject::instanceMethodName)\n" +
                        " 3) Ссылка на метод произвольного объекта конкретного\n" +
                        "    типа(ContainingType::methodName)\n" +
                        " 4) Ссылка на конструктор(ClassName::new), для дженериков (generics) Class<T> :: new."); //ответ 188
        answersList.add(" Выражение System.out::println является ссылкой на статический метод println\n" +
                        " обьекта out класа System, который эквивалентен лямбда-выражению\n" +
                        " x -> System.out.println(x)."); //ответ 189
        answersList.add(" Функциональный интерфейс - это тот интерфейс, который определяет строго один\n" +
                        " абстрактный метод. В Java 8 была введена новая аннотация @FunctionalInterface\n" +
                        " для обозначения интерфейса, функциональным, эта аннотация используется для того,\n" +
                        " чтобы избежать случайного добавления абстрактных методов в функциональный интерфейс.\n" +
                        " Она не обязательна, но является хорошей практикой написания кода. Функциональные\n" +
                        " интерфейсы позволяют нам использовать лямбда-выражения для создания экземпляра\n" +
                        " таких интерфейсов. Лучшим примером функционального интерфейса будет интерфейс\n" +
                        " java.lang.Runnable с одним абстрактным методом run(). Заметим, интерфейс может\n" +
                        " включать сколько угодно default методов и при этом оставаться функциональным,\n" +
                        " потому что default методы - не абстрактные."); //ответ 190
        answersList.add(" Представляет собой операцию, которая принимает два входных параметра,\n" +
                        " и не возвращает никакого результата."); //ответ 191
        answersList.add(" Представляет собой функцию, которая принимает два аргумента и возвращает результат."); //ответ 192
        answersList.add(" Представляет собой операцию над двумя операндами одного и того же типа, выполняет\n" +
                        " над ними бинарную операцию и возвращает результат того же типа, что и операнды."); //ответ 193
        answersList.add(" Представляет собой предикат (булеву функцию) двух аргументов."); //ответ 194
        answersList.add(" Представляет собой поставщика булевых результатов."); //ответ 195
        answersList.add(" Представляет собой операцию, которая принимает один входной аргумент, выполняет\n" +
                        " некоторое действие над объектом типа T, при этом ничего не возвращая."); //ответ 196
        answersList.add(" Представляет собой операцию над двумя операндами типа double, возвращает\n" +
                        " результат типа double."); //ответ 197
        answersList.add(" Представляет собой операцию, которая принимает один аргумент типа double,\n" +
                        " и не возвращает результат."); //ответ 198
        answersList.add(" Представляет собой функцию, которая принимает один аргумент типа double,\n" +
                        " и возвращает результат.");  //ответ 199
        answersList.add(" Представляет собой предикат (булеву функцию) одного аргумента типа double."); //ответ 200
        answersList.add(" Представляет собой поставщика double результатов."); //ответ 201
        answersList.add(" Представляет собой функцию, которая принимает один аргумент типа double,\n" +
                        " возвращает результат типу int."); //ответ 202
        answersList.add(" Представляет собой функцию, которая принимает один аргумент типа double,\n" +
                        " и возвращает результат типу long."); //ответ 203
        answersList.add(" Представляет собой операцию над одним аргументом типа double, возвращает\n" +
                        " результат типу double."); //ответ 204
        answersList.add(" Представляет собой функцию перехода от объекта типа T к объекту типа R."); //ответ 205
        answersList.add(" Представляет собой операцию над двумя операндами типа int, возвращает\n" +
                        " результат типа int."); //ответ 206
        answersList.add(" Представляет собой операцию, которая принимает один аргумент типа int,\n" +
                        " и не возвращает результат."); //ответ 207
        answersList.add(" Представляет собой операцию, которая принимает один аргумент типа int,\n" +
                        " возвращает результат."); //ответ 208
        answersList.add(" Представляет собой предикат (булеву функцию) одного аргумента типа int."); //ответ 209
        answersList.add(" Представляет собой поставщика int результатов."); //ответ 210
        answersList.add(" Представляет собой функцию, которая принимает один аргумент типа int,\n" +
                        " возвращает результат типу double."); //ответ 211
        answersList.add(" Представляет собой функцию, которая принимает один аргумент типа int,\n" +
                        " возвращает результат типу long."); //ответ 212
        answersList.add(" Представляет собой операцию над одним аргументом типа int, возвращает\n" +
                        " результат типу int."); //ответ 213
        answersList.add(" Представляет собой операцию над двумя операндами типа long, возвращает\n" +
                        " результат типа long."); //ответ 214
        answersList.add(" Представляет собой операцию, которая принимает один аргумент типа long,\n" +
                        " не возвращает результат."); //ответ 215
        answersList.add(" Представляет собой функцию, которая принимает один аргумент типа long,\n" +
                        " и возвращает результат."); //ответ 216
        answersList.add(" Представляет собой предикат (булеву функцию) одного аргумента типа long."); //ответ 217
        answersList.add(" Представляет собой поставщика long результатов."); //ответ 218
        answersList.add(" Представляет собой функцию, которая принимает один аргумент типа long,\n" +
                        " и возвращает результат типу double."); //ответ 219
        answersList.add(" Представляет собой функцию, которая принимает один аргумент типа long,\n" +
                        " и возвращает результат типу int."); //ответ 220
        answersList.add(" Представляет собой операцию над одним аргументом типа long, возвращает\n" +
                        " результат типу long."); //ответ 221
        answersList.add(" Представляет собой операцию, которая принимает один аргумент типа object,\n" +
                        " и второй типа double, и не возвращает результат."); //ответ 222
        answersList.add(" Представляет собой операцию, которая принимает один аргумент типа object,\n" +
                        " и второй типа int, и не возвращает результат."); //ответ 223
        answersList.add(" Представляет собой операцию, которая принимает один аргумент типа object,\n" +
                        " и второй типа long, и не возвращает результат."); //ответ 224
        answersList.add(" Представляет собой предикат (булеву функцию) одного аргумента."); //ответ 225
        answersList.add(" Представляет собой поставщика результатов."); //ответ 226
        answersList.add(" Представляет собой функцию, которая принимает два аргумента, возвращает\n" +
                        " результат типу double."); //ответ 227
        answersList.add(" Представляет собой функцию, которая принимает один аргумент, возвращает\n" +
                        " результат типа double."); //ответ 228
        answersList.add(" Представляет собой функцию, которая принимает два аргумента, возвращает\n" +
                        " результат типу int."); //ответ 229
        answersList.add(" Представляет собой функцию, которая принимает один аргумент, возвращает\n" +
                        " результат типа int."); //ответ 230
        answersList.add(" Представляет собой функцию, которая принимает два аргумента, возвращает\n" +
                        " результат типу long."); //ответ 231
        answersList.add(" Представляет собой функцию, которая принимает один аргумент, возвращает\n" +
                        " результат типа long."); //ответ 232
        answersList.add(" Представляет собой операцию над одним операндом, возвращает результат\n" +
                        " того же типа, что и операнд."); //ответ 233
        answersList.add(" StringJoiner используется, чтобы создать последовательность символов,\n" +
                        " разделенных разделителем, может (но это не обязательно) начинаться с префикса\n" +
                        " и заканчиваться суффиксом. Пример:\n\n" +
                        " StringJoiner strJoiner = new StringJoiner(\".\");\n" +
                        " strJoiner.add(\"Jse\").add(\"Helper\");" +
                        " System.out.println(strJoiner); // prints Jse.Helper"); //ответ 234
        answersList.add(" Начиная с Java 8 мы можем использовать в интерфейсах стандартные методы\n" +
                        " (default methods) и статические методы (static methods).\n" +
                        " Default метод - это метод в интерфейсе с по умолчанию реализованной логикой,\n" +
                        " который не требуется обязательно определять в реализации этого интерфейса:\n\n" +
                        " public interface Vehicle {\n" +
                        "    default void print() {\n" +
                        "       System.out.println(\"I am a vehicle!\");" +
                        "    }\n\n" +
                        "    static void blowHorn() {\n" +
                        "       System.out.println(\"Blowing horn!!!\");\n" +
                        "    }\n" +
                        " }"); //ответ 235
        answersList.add(" Static-методы в интерфейсе - это по существу то же самое, что static-методы\n" +
                        " в абстрактном классе. Статические методы в интерфейсе являются частью интерфейса,\n" +
                        " мы не можем использовать его для объектов класса реализации:" +
                        " 1) Статические методы в интерфейсе являются частью интерфейса, мы не можем\n" +
                        "    использовать его для объектов класса реализации.\n" +
                        " 2) Статические методы в интерфейсе хороши для обеспечения вспомогательных\n" +
                        "    методов, например, проверки на null, сортировки коллекций и т.д.\n" +
                        " 3) Статические методы в интерфейсе помогают обеспечивать безопасность,\n" +
                        "    не позволяя классам, которые реализуют интерфейс, переопределить их.\n" +
                        " 4) Мы не можем определить статические методы для методов класса Object,\n" +
                        "    потому что получим ошибку компиляции."); //ответ 236
        answersList.add(" Используя ключевое слово super вместе с именем интерфейса:\n\n" +
                        " interface Vehicle {\n" +
                        "    default void print() {\n" +
                        "       System.out.println(\"I am a vehicle!\");\n" +
                        "    }\n\n" +
                        " class Car implements Vehicle {\n" +
                        "    public void print() {\n" +
                        "       Vehicle.super.print();\n" +
                        "    }\n" +
                        " }"); //ответ 237
        answersList.add(" Используя имя интерфейса:\n\n" +
                        " interface Vehicle {\n" +
                        "   static void blowHorn() {\n" +
                        "      System.out.println(\"Blowing horn!!!\");" +
                        "   }\n" +
                        " }\n\n" +
                        " class Car implements Vehicle {\n" +
                        "    public void print() {\n" +
                        "       Vehicle.blowHorn();\n" +
                        "    }\n" +
                        " }"); //ответ 238
        answersList.add(" java.util.stream - введен для поддержки распараллеливания вычислений в потоках.\n" +
                        " Предоставляет возможность обрабатывать последовательность элементов исполняя одну\n" +
                        " или несколько операций, которые могут выполняться либо последовательно либо\n" +
                        " паралельно. Потоки делятся на последовательные и параллельные. Самая большая\n" +
                        " польза от этого - в работе с коллекциями.\n" +
                        " Операции над потоком относятся либо к промежуточным, либо к терминальным.\n" +
                        " Все промежуточные операции возвращают поток, так что мы можем объединять\n" +
                        " несколько промежуточных операций без использования точки с запятой.\n" +
                        " Терминальные операции возвращают void или непотоковый результат."); //ответ 239
        answersList.add(" Большинство операций класса Stream, которые модифицируют набор данных,\n" +
                        " возвращают этот набор в виде потока. Однако бывают ситуации, когда хотелось бы\n" +
                        " получить данные не в виде потока, а в виде обычной коллекции, например,\n" +
                        " ArrayList или HashSet. И для этого у класса Stream определен метод collect.\n" +
                        " Метод принимает в качестве параметра функцию преобразования к коллекции:\n\n" +
                        " <R,A> R collect(Collector<? super T,A,R> collector)\n\n" +
                        " Параметр R представляет тип результата метода, параметр Т - тип элемента\n" +
                        " в потоке, а параметр А - тип промежуточных накапливаемых данных.\n" +
                        " В итоге параметр collector представляет функцию преобразования потока в коллекцию."); //ответ 240
        answersList.add(" Разница между коллекцией(Collection) данных и потоком(Stream) из новой JDK 8\n" +
                        " в том что коллекции позволяют работать с элементами по-отдельности, тогда как\n" +
                        " поток(Stream) не позволяет. Например, с использованием коллекций, вы можете\n" +
                        " добавлять элементы, удалять, и вставлять в середину. Поток(Stream) не позволяет\n" +
                        " манипулировать отдельными элементами из набора данных, но вместо этого позволяет\n" +
                        " выполнять функции над данными как одним целом."); //ответ 241
        answersList.add(" Метод void forEach(Consumer<? super T> action) - для каждого элемента выполняется\n" +
                        " действие action. forEach является терминальной операцией, используется для перебора\n" +
                        " каждого элемента потока. forEach не гарантирует последовательности вывода элементов\n" +
                        " в параллельном stream-е, для этого используется метод forEachOrdered - он это\n" +
                        " гарантирует."); //ответ 242
        answersList.add(" Следующий фрагмент кода показывает, как вывести 10 случайных чисел с помощью forEach:\n\n" +
                        " Random random = new Random();\n" +
                        " random.ints().limit(10).forEach(System.out::println);"); //ответ 243
        answersList.add(" Метод <R> Stream<R> map(Function<? super T,? extends R> mapper) - преобразует элементы\n" +
                        " типа T в элементы типа R и возвращает поток с элементами R. map является промежуточной\n" +
                        " операцией, метод используется для преобразования элементов в другой объект при помощи\n" +
                        " переданной функции."); //ответ 244
        answersList.add(" Следующий фрагмент кода демонстрирует это, используя метод map:\n\n" +
                        " List<Integer> numbers = Arrays.asList(3,2,2,3,7,3,5);\n" +
                        " //get list of unique squares\n" +
                        " List<Integer> squaresList = numbers.stream().map(i -> i*i).distinct().collect(Collectors.toList());"); //ответ 245
        answersList.add(" Метод Stream<T> filter(Predicate<? super T> predicate) - фильтрует\n" +
                        " элементы в соответствии с условием в предикате. filter является промежуточной\n" +
                        " операцией, используется для фильтрации массива через функцию.\n" +
                        " На самом деле filter, не выполняет фильтрацию, вместо этого он создается новый поток,\n" +
                        " который по завершению формирования, содержит элементы исходного потока, которые\n" +
                        " соответствуют заданному предикату."); //ответ 246
        answersList.add(" Следующий фрагмент кода демонстрирует это с помощью метода filter:\n\n" +
                        " List<String> strings = Arrays.asList(\"abc\",\"\",\"bc\",\"efg\",\"abcd\",\"\",\"jkl\");\n" +
                        " //get count of empty String\n" +
                        " long count = strings.stream().filter(String -> String.isEmpty()).count();"); //ответ 247
        answersList.add(" Метод Stream<T> limit(long maxSize) - оставляет в потоке только maxSize элементов.\n" +
                        " limit является промежуточной операцией, используется для выборки первых maxSize элементов\n" +
                        " потока. Этот метод также возвращает модифицированный поток, в котором не более maxSize\n" +
                        " элементов."); //ответ 248
        answersList.add(" Метод Stream<T> sorted()/Stream<T> sorted(Comparator<? super T> comparator)\n" +
                        " - возвращает отсортированный поток. sorted является промежуточной операцией,\n" +
                        " метод используется для сортировки потока используя естественный порядок сравнения\n" +
                        " его элементов. Существует также второй метод sorted(), принимающий либо экземпляр\n" +
                        " Comparable, либо соответствующее ему лямбда-выражение."); //ответ 249
        answersList.add(" Следующий фрагмент кода демонстрирует это:\n\n" +
                        " Random random = new Random();\n" +
                        " random.ints().limit(10).sorted().forEach(System.out::println);"); //ответ 250
        answersList.add(" Чтобы сделать обычный последовательный поток параллельным, надо вызвать у объекта\n" +
                        " Stream метод parallel. Кроме того, можно также использовать метод parallelStream()\n" +
                        " интерфейса Collection для создания параллельного потока из коллекции.\n" +
                        " В то же время если рабочая машина не является многоядерной, то поток будет\n" +
                        " выполняться как последовательный. Следующий фрагмент кода, выводит количество\n" +
                        " пустых строк с помощью метода parallelStream.\n" +
                        " List<String> strings = Arrays.asList(\"abc\",\"\",\"bc\",\"efg\",\"abcd\",\"\",\"jkl\");\n" +
                        " //get count of empty String\n" +
                        " long count = strings.parallelStream().filter(String -> String.isEmpty()).count();"); //ответ 251
        answersList.add(" Следующий код выводит наибольшее число которое присутствует в списке:\n\n" +
                        " List<Integer> numbers = Arrays.asList(3,2,2,3,7,3,5);\n" +
                        " IntSummaryStatistics stats = numbers.stream().mapToInt((x) -> x).summaryStatistics();\n" +
                        " System.out.println(\"Highest number in List:\" + stats.getMax());"); //ответ 252
        answersList.add(" Следующий код выводит минимальное число которое присутствует в списке:\n\n" +
                        " List<Integer> numbers = Arrays.asList(3,2,2,3,7,3,5);\n" +
                        " IntSummaryStatistics stats = numbers.stream().mapToInt((x) -> x).summaryStatistics();\n" +
                        " System.out.println(\"Lowest number in List:\" + stats.getMin());"); //ответ 253
        answersList.add(" Следующий код выведет сумму всех чисел:\n\n" +
                        " List<Integer> numbers = Arrays.asList(3,2,2,3,7,3,5);\n" +
                        " IntSummaryStatistics stats = numbers.stream().mapToInt((x) -> x).summaryStatistics();\n" +
                        " System.out.println(\"Sum of all numbers:\" + stats.getSum());");  //ответ 254
        answersList.add(" Следующий код выведет среднее значение всех чисел:\n\n" +
                        " List<Integer> numbers = Arrays.asList(3,2,2,3,7,3,5);\n" +
                        " IntSummaryStatistics stats = numbers.stream().mapToInt((x) -> x).summaryStatistics();\n" +
                        " System.out.println(\"Average of all numbers:\" + stats.getAverage());"); //ответ 255
        answersList.add(" Optional - это контейнер объекта, он может содержать значение или некоторый тип Т,\n" +
                        " или просто быть null. Он предоставляет много полезных методов избавляющие от добавления\n" +
                        " повторяющихся if null/notNull проверок, что позволяет нам сфокусироваться на том,\n" +
                        " что мы хотим сделать. Метод isPresent() возвращает true если экземпляр Optional\n" +
                        " содержит не null значение и false в противном случае. Метод orElseGet() содержит\n" +
                        " запасной механизм результата, если Optional содержит null, принимая функции для\n" +
                        " генерации значения по умолчанию. Метод map() преобразует текущее значение Optional\n" +
                        " и возвращает новый экземпляр Optional. Метод orElse() похож на orElseGet(),\n" +
                        " но вместо функции он принимает значение по умолчанию.");
        answersList.add(" Nashorn - это движок JavaScript, разрабатываемый полностью на Java компанией Oracle.\n" +
                        " Он призван дать возможность встраивать код JavaScript в приложения Java. В сравнении\n" +
                        " с Rhino, который поддерживается Mozilla Foundation, Nashorn обеспечивает от 2 до 10 раз\n" +
                        " более высокую производительность, так как он непосредственно компилирует код в памяти и\n" +
                        " передает байт-код виртуальной машине Java. Nashorn умеет компилировать код JavaScript и\n" +
                        " генерировать классы Java, которые загружаются специальным загрузчиком. Возможен вызов\n" +
                        " кода Java прямо из JavaScript."); //ответ 257
        answersList.add(" Nashorn поставляется с cmd-утилитой jjs, которая позволяет исполнять JavaScript прямо\n" +
                        " в консоли. jjs принимает список JavaScript файлов исходного кода и запускает их. Чтобы\n" +
                        " запустить файл давайте передадим его как аргумент в jjs:\n" +
                        " jjs fileName.js"); //ответ 258
        answersList.add(" LocalDateTime объединяет вместе LocaleDate и LocalTime и содержит дату и время, но без\n" +
                        " часового пояса в календарной системе ISO-8601. Время хранится с точностью до наносекунды,\n" +
                        " так что в LocalTime можно хранить, например, величину \"13:45.30.123456789\".\n" +
                        " Есть множество удобных методов, таких как plusMinutes, plusHours, isAfter, toSecondOfDay\n" +
                        " и т.д."); //ответ 259
        answersList.add("ZonedDateTime - аналог java.util.Calendar. Это самый мощный класс с полной информацией\n" +
                        " о временном контексте, включает временную зону. Он содержит дату и время в календарной\n" +
                        " системе ISO-8601."); //ответ 260
        answersList.add(" Следующий код выводит текущую дату:\n\n" +
                         " //Get the current date\n" +
                        " LocalDate today = LocalDate.now();\n" +
                        " System.out.println(\"Current date: \" + today);"); //ответ 261
        answersList.add(" Следующий код добавляет 1 неделю к текущей дате:\n\n" +
                        " //add 1 week to the current date\n" +
                        " LocalDate today = LocalDate.now();\n" +
                        " LocalDate nextWeek = today.plus(1, ChronoUnit.WEEKS);" +
                        " System.out.println(\"Next week: \" + nextWeek);"); //ответ 262
        answersList.add(" Следующий код добавляет 1 месяц к текущей дате:\n\n" +
                        " //add 1 month to the current date\n" +
                        " LocalDate today = LocalDate.now();\n" +
                        " LocalDate nextMonth = today.plus(1, ChronoUnit.MONTHS);\n" +
                        " System.out.println(\"Next month: \" + nextMonth);"); //ответ 263
        answersList.add(" Следующий код добавляет 1 год к текущей дате:\n\n" +
                        " //add 1 year to the current date\n" +
                        " LocalDate today = LocalDate.now();\n" +
                        " LocalDate nextYear = today.plus(1, ChronoUnit.YEARS);\n" +
                        " System.out.println(\"Next year: \" + nextYear);"); //ответ 264
        answersList.add(" Следующий код добавляет 10 лет к текущей дате:\n\n" +
                        " //add 10 years to the current date\n" +
                        " LocalDate today = LocalDate.now();\n" +
                        " LocalDate nextDecade = today.plus(1, ChronoUnit.DECADES);\n" +
                        " System.out.println(\"Date after ten years: \" + nextDecade);"); //ответ 265
        answersList.add(" Следующий код возвращает следующий вторник:\n\n" +
                        " //get the next Tuesday\n" +
                        " LocalDate today = LocalDate.now();\n" +
                        " LocalDate nextTuesday = today.with(TemporalAdjusters.next(DayOfWeek.TUESDAY));\n" +
                        " System.out.println(\"Next Tuesday on: \" + nextTuesday);"); //ответ 266
        answersList.add(" Следующий код демонстрирует это:\n\n" +
                        " //get the second Saturday of current month\n" +
                        " LocalDate today = LocalDate.now();\n" +
                        " LocalDate firstInYear = LocalDate.of(today.getYear(), today.getMonth(), 1);\n" +
                        " LocalDate secondSuturday = firstInYear.with(TemporalAdjusters.nextOrSame(DayOfWeek.SATURDAY)\n" +
                        "                                       .with(TemporalAdjusters.next(DayOfWeek.SATURDAY));\n" +
                        " System.out.println(\"Second Saturday on: \" + secondSaturday);"); //ответ 267
        answersList.add(" Следующий код возвращает дату в миллисекундах:\n\n" +
                        " //get the instant of current date in terms of milliseconds\n" +
                        " Date currentDate = new Date();\n" +
                        " Instant now = currentDate.toInstant();\n" +
                        " System.out.println(\"Current date: \" + now);"); //ответ 268
        answersList.add(" Следующий код демонстрирует это:\n\n" +
                        " Date currentDate = new Date();\n" +
                        " Instant now = currentDate.toInstant();\n" +
                        " ZoneId currentZone = ZoneId.systemDefault();\n" +
                        " LocalDateTime localDateTime = LocalDateTime.ofInstant(now, currentZone);\n" +
                        " System.out.println(\"Local date: \" + localDateTime);"); //ответ 269
        answersList.add(" В Java 8 для этого появился класс public static class Base64.Decoder - этот\n" +
                        " класс реализует декодер для декодирования байт данных, используя схему\n" +
                        " кодирования Base64 как указано в RFC 4648 и RFC 2045, класс безопасен для\n" +
                        " использования несколькими параллельными потоками."); //ответ 270
        answersList.add(" В Java 8 для этого появился класс public static class Base64.Encoder - этот\n" +
                        " класс реализует кодер для кодирования байт данных, используя схему\n" +
                        " кодирования Base64 как указано в RFC 4648 и RFC 2045, класс безопасен для\n" +
                        " использования несколькими параллельными потоками."); //ответ 271
        answersList.add(" Используя метод getDecoder() класса Base64 он возвращает декодировщик\n" +
                        " Base64.Decoder, который декодирует данные с помощью схемы кодирования\n" +
                        " base64."); //ответ 272
        answersList.add(" Используя метод getEncoder() класса Base64 он возвращает кодировщик\n" +
                        " Base64.Encoder, который кодирует данные с помощью схемы кодирования base64."); //ответ 273

        //5) ПОТОКИ ВВОДА/ВЫВОДА В JAVA
        answersList.add(" Символьная ссылка (Symbolic link, симлинк) - специальный файл в файловой\n" +
                        " системе, содержащий только текстовую строку с указателем. Эта строка\n" +
                        " трактуется как путь к файлу, который должен быть открыт при попытке\n" +
                        " обратиться к данному файлу."); //ответ 274
        answersList.add(" I/O (input/output, ввод-вывод ) - взаимодействие между обработчиком информации\n" +
                        " и её поставщиком и/или получателем. Ввод - сигнал или данные, полученные\n" +
                        " обработчиком, а вывод - сигнал или данные, посланные им (или из него).\n" +
                        " NIO (/*в контексте Java*/ Non-blocking I/O, New I/O) - коллекция прикладных\n" +
                        " программных интерфейсов для языка Java, предназначенных для реализации\n" +
                        " высокопроизводительных операций ввода-вывода. Также встречается аббревиатура\n" +
                        " NIO.2 - она относится к нововведениям относительно этого направления в Java 7."); //ответ 275
        answersList.add(" Ключевые особенности NIO:\n" +
                        " 1) Каналы и селекторы: NIO поддерживает различные типы каналов. Канал является\n" +
                        "    абстракцией объектов более низкого уровня файловой системы (например,\n" +
                        "    отображенные в памяти файлы и блокировки файлов), что позволяет передавать\n" +
                        "    данные с более высокой скоростью. Каналы не блокируются и поэтому Java\n" +
                        "    предоставляет еще такие инструменты, как селектор, который позволяет выбрать\n" +
                        "    готовый канал для передачи данных, и сокет, который является инструментом\n" +
                        "    для блокировки.\n" +
                        " 2) Буферы: в Java 7 была введена буферизация для всех классов-обёрток примитивов\n" +
                        "    (кроме Boolean). Появился абстрактный класс Buffer, который предоставляет такие\n" +
                        "    операции, как clear, flip, mark и т.д. Его подклассы предоставляют методы для\n" +
                        "    получения и установки данных.\n" +
                        " 3) Кодировки: в Java 7 появились кодировки (java.nio.charset), кодеры и декодеры\n" +
                        "    для отображения байт и символов Unicode."); //ответ 276
        answersList.add(" Потоки ввода/вывода используются для передачи данных в файловые потоки, на консоль\n" +
                        " или на сетевые соединения. Существует два вида потоков ввода/вывода: байтовые\n" +
                        " и символьные.\n"); //ответ 277
        answersList.add(" 1) байтовые: java.io.InputStream, java.io.OutputStream\n" +
                        " 2) символьные: java.io.Reader, java.io.Writer\n" +
                        " оба вида являются прямыми наследниками класса Object"); //ответ 278
        answersList.add(" Класс OutputStream - это абстрактный класс, определяющий потоковый байтовый вывод.\n" +
                        " В этой категории находятся классы, определяющие, куда направляются ваши данные:\n" +
                        " в массив байтов (но не напрямую в String; предполагается что вы сможете создать\n" +
                        " их из массива байтов), в файл или канал.\n" +
                        " Базовый класс InputStream представляет классы, которые получают данные из различных\n" +
                        " источников:\n" +
                        " 1) массив байтов,\n" +
                        " 2) строка (String),\n" +
                        " 3) файл,\n" +
                        " 4) канал (pipe): данные помещаются с одного конца и извлекаются с другого,\n" +
                        " 5) последовательность различных потоков, которые можно объединить в одном потоке,\n" +
                        " 6) другие источники (например, подключение к интернету).\n" +
                        " Символьные потоки имеют два основных абстрактных класса Reader и Writer,\n" +
                        " управляющие потоками символов Unicode. Класс Reader - абстрактный класс,\n" +
                        " определяющий символьный потоковый ввод. Класс Writer - абстрактный класс,\n" +
                        " определяющий символьный потоковый вывод. В случае ошибок все методы класса\n" +
                        " передают исключение IOException."); //ответ 279
        answersList.add(" Подклассы базового класса InputStream:\n" +
                        " 1) StringBufferInputStream - превращает строку (String) во входной поток данных\n" +
                        "    InputStream.\n" +
                        " 2) SequenceInputStream - сливает два или более потока InputStream в единый поток.\n" +
                        " 3) PushbackInputStream - входной поток, поддерживающий однобайтовый возврат\n" +
                        "    во входной поток.\n" +
                        " 4) PrintStream - выходной поток, включающий методы print() и println().\n" +
                        " 5) PipedInputStream - реализует понятие входного канала.\n" +
                        " 6) ObjectInputStream - входной поток для объектов.\n" +
                        " 7) InputStream - абстрактный класс, описывающий поток ввода.\n" +
                        " 8) FilterInputStream - абстрактный класс, предоставляющий интерфейс\n" +
                        "    для классов-надстроек, которые добавляют к существующим потокам\n" +
                        "    полезные свойства.\n" +
                        " 9) FileInputStream - для чтения информации из файла.\n" +
                        "10) DataInputStream - входной поток, включающий методы для чтения стандартных\n" +
                        "    типов данных Java.\n" +
                        "11) ByteArrayInputStream - позволяет использовать буфер в памяти (массив байтов)\n" +
                        "    в качестве источника данных для входного потока.\n" +
                        "12) BufferedInputStream - буферизированный входной поток."); //ответ 280
        answersList.add(" RandomAccessFile это класс который наследуется напрямую от Object и не наследуется\n" +
                        " от вышеприведенных базовых классов ввода\\вывода. Предназначен для работы с файлами,\n" +
                        " поддерживая произвольный доступ к их содержимому.\n" +
                        " Работа с классом RandomAccessFile напоминает использование совмещенных в одном классе\n" +
                        " потоков DataInputStream и DataOutputStream (они реализуют те же интерфейсы DataInput\n" +
                        " и DataOutput). Кроме того, метод seek() позволяет переместиться к определенной позиции\n" +
                        " и изменить хранящееся там значение. При использовании RandomAccessFile необходимо\n" +
                        " знать структуру файла. Класс RandomAccessFile содержит методы для чтения и записи\n" +
                        " примитивов и строк UTF-8."); //ответ 281
        answersList.add(" RandomAccessFile может открываться в режиме чтения (\"r\") или чтения/записи (\"rw\").\n" +
                        " Также есть режим \"rws\", когда файл открывается для операций чтения-записи и каждое\n" +
                        " изменение данных файла немедленно записывается на физическое устройство."); //ответ 282
        answersList.add(" Класс OutputStream - это абстрактный класс, определяющий потоковый байтовый вывод.\n" +
                        " В этой категории находятся классы, определяющие, куда направляются ваши данные:\n" +
                        " в массив байтов (но не напрямую в String; предполагается что вы сможете создать\n" +
                        " их из массива байтов), в файл или канал.\n" +
                        " Подклассы базового класса OutputStream:\n" +
                        " 1) PipedOutputStream - реализует понятие выходного канала.\n" +
                        " 2) ObjectOutputStream - выходной поток для объектов\n" +
                        " 3) FilterOutputStream - абстрактный класс, предоставляющий интерфейс\n" +
                        "    для классов-надстроек, которые добавляют к существующим потокам полезные\n" +
                        "    свойства.\n" +
                        " 4) FileOutputStream - отправка данных в файл на диске. Реализация класса\n" +
                        "    OutputStream.\n" +
                        " 5) DataOutputStream - выходной поток, включающий методы для записи стандартных\n" +
                        "    типов данных Java.\n" +
                        " 6) ByteArrayOutputStream - создает буфер в памяти. Все данные, посылаемые в этот\n" +
                        "    поток, размещаются в созданном буфере.\n" +
                        " 7) BufferedOutputStream - буферизированный выходной поток."); //ответ 283
        answersList.add(" Разновидность буферизации, обеспечивающая чтение байта с последующим его возвратом\n" +
                        " в поток. Класс PushbackInputStream представляет механизм \"заглянуть\" во входной\n" +
                        " поток и увидеть, что оттуда поступит в следующий раз, не извлекая информации.\n" +
                        " У класса есть дополнительный метод unread().\n"); //ответ 284
        answersList.add(" Класс SequenceInputStream позволяет соединять вместе несколько экземпляров класса\n" +
                        " InputStream. Конструктор принимает в качестве аргумента либо пару объектов класса\n" +
                        " InputStream, либо интерфейс Enumeration.\n" +
                        " Во время работы класс выполняет запросы на чтение из первого объекта класса\n" +
                        " InputStream и до конца, а затем переключается на второй. При использовании\n" +
                        " интерфейса работа продолжится по всем объектам класса InputStream.\n" +
                        " По достижении конца каждого файла, связанный с ним поток закрывается.\n" +
                        " Закрытие потока, созданного объектом класса SequenceInputStream, приводит\n" +
                        " к закрытию всех открытых потоков."); //ответ 285
        answersList.add(" Подклассы базового класса Reader:\n" +
                        " 1) StringReader - входной поток, читающий из строки.\n" +
                        " 2) Reader - абстрактный класс, описывающий символьный ввод.\n" +
                        " 3) PushbackReader - входной поток, позволяющий возвращать символы обратно\n" +
                        "    в поток.\n" +
                        " 4) PipedReader - входной канал.\n" +
                        " 5) LineNumberReader - входной поток, подсчитывающий строки.\n" +
                        " 6) InputStreamReader - входной поток, транслирующий байты в символы.\n" +
                        " 7) FilterReader - фильтрующий читатель.\n" +
                        " 8) FileReader - входной поток, читающий файл.\n" +
                        " 9) CharArrayReader - входной поток, который читает из символьного массива.\n" +
                        "10) BufferedReader - буферизированный входной символьный поток."); //ответ 286
        answersList.add(" Подклассы базового класса Writer:\n" +
                        " 1) Writer - абстрактный класс, описывающий символьный вывод,\n" +
                        " 2) StringWriter - выходной поток, пишущий в строку,\n" +
                        " 3) PrintWriter - выходной поток, включающий методы print() и println(),\n" +
                        " 4) PipedWriter - выходной канал,\n" +
                        " 5) OutputStreamWriter - выходной поток, транслирующий байты в символы,\n" +
                        " 6) FilterWriter - фильтрующий писатель,\n" +
                        " 7) FileWriter - выходной поток, пишущий в файл,\n" +
                        " 8) CharArrayWriter - выходной поток, который пишет в символьный массив,\n" +
                        " 9) BufferedWriter - буферизированный выходной символьный поток."); //ответ 287
        answersList.add(" Абсолютный путь - это путь, который указывает на одно и то же место\n" +
                        " в файловой системе, вне зависимости от текущей директории. Полный путь\n" +
                        " всегда начинается с корневого каталога.\n" +
                        " Относительный путь - это путь по отношению к текущему рабочему каталогу."); //ответ 288
        answersList.add(" Стандартный классы ввода\\вывода в Java лежат в пакете java.io.*.\n" +
                        " В JDK 7 добавлен более современный способ работы с потоками под названием\n" +
                        " Java NIO или Java New IO. Эти классы лежат в пакете java.nio.*.\n" +
                        " Для работы с архивами используются классы из пакета java.util.*."); //ответ 289
        answersList.add(" Классы-настройки ето классы которые добавляют к существующим потокам\n" +
                        " полезные дополнительные свойства.\n" +
                        " Примеры классов: BufferedOutputStream, BufferedInputStrem, BufferedWriter,\n" +
                        " BufferedReader - буферезируют поток и повышают производительность."); //ответ 290
        answersList.add(" Для чтения байтовых данных (не строк) применяется класс DataInputStream.\n" +
                        " В этом случае необходимо использовать классы из группы InputStream.\n" +
                        " Для преобразования строки в массив байтов, пригодный для помещения\n" +
                        " в поток ByteArrayInputStream, в классе String предусмотрен метод getBytes().\n" +
                        " Полученный ByteArrayInputStream представляет собой поток InputStream, подходящий\n" +
                        " для передачи DataInputStream.\n" +
                        " При побайтовом чтении символов из форматированного потока DataInputStream методом\n" +
                        " readByte() любое полученное значение будет считаться действительным, поэтому\n" +
                        " возвращаемое значение неприменимо для идентификации конца потока. Вместо этого\n" +
                        " можно использовать метод available(), который сообщает, сколько еще осталось\n" +
                        " символов. Класс DataInputStream позволяет читать элементарные данные из потока\n" +
                        " через интерфейс DataInput, который определяет методы, преобразующие элементарные\n" +
                        " значения в форму последовательности байтов. Такие потоки облегчают сохранение\n" +
                        " в файле двоичных данных."); //ответ 291
        answersList.add(" Для этого используются классы, позволяющие буферизировать поток:\n" +
                        " 1) java.io.BufferedInputStream - буферизированный входной поток. Конструкторы:\n" +
                        "    BufferedInputStream(InputStream in), BufferedInputStream(InputStream in, int size).\n" +
                        " 2) java.io.BufferedOutputStream - буферизированный выходной поток. Конструкторы:\n" +
                        "    BufferedOutputStream(OutputStream out), BufferedOutputStream(OutputStream out, int size).\n" +
                        " 3) java.io.BufferedReader - буферизированный входной символьный поток. Конструкторы:\n" +
                        "    BufferedReader(Reader r), BufferedReader(Reader in, int sz).\n" +
                        " 4) java.io.BufferedWriter - буферизированный выходной символьный поток. Конструкторы:\n" +
                        "    BufferedWriter(Writer out), BufferedWriter(Writer out, int sz).");
        answersList.add(" OutputStreamWriter - это мост между классом OutputStream и классом Writer.\n" +
                        " Символы, записанные в поток, преобразовываются в байты:\n\n" +
                        " OutputStream outputStream = new FileOutputStream(\"c:\\data\\output.txt);\n" +
                        " Writer outputStreamWriter = new OutputStreamWriter(outputStream, \"UTF-8\");\n\n" +
                        " outputStreamWriter.write(\"Hello World\");\n\n" +
                        " outputStreamWriter.close();\n\n" +
                        " InputStreamReader - аналог для чтения. При помощи методов класса Reader читаются\n" +
                        " байты из потока InputStream и далее преобразуются в символы:\n\n" +
                        " InputStream inputStream = new FileInputStream(\"c:\\data\\input.txt\");\n" +
                        " Reader inputStreamReader = new InputStreamReader(inputStream,\"UTF-8\");\n\n" +
                        " int data = inputStreamReader.read();\n" +
                        " while(data != -1) {\n" +
                        "   char theCar = (char)data;\n" +
                        "   data = inputStreamReader.read();\n" +
                        " }\n\n" +
                        " inputStreamReader close();"); //ответ 293
        answersList.add(" Прежде всего, в классе PrintWriter применен усовершенствованный способ работы\n" +
                        " с символами UNICODE и другой механизм буферизации вывода. В классе PrintStream\n" +
                        " буфер вывода сбрасывался всякий раз, когда вызывался метод print или println.\n" +
                        " При использовании класса PrintWriter вы можете отказаться от автоматического\n" +
                        " сброса буферов, выполняя его явным образом при помощи метода flush. В классе\n" +
                        " PrintWriter предусмотрено два конструктора, позволяющих работать с выходными\n" +
                        " потоками класса OutputStream:\n" +
                        " 1) public PrintWriter(OutputStream out); - создает поток без автоматического\n" +
                        "    сброса буферов.\n" +
                        " 2) public PrintWriter(OutputStream out, boolean autoFlush); - способ сброса\n" +
                        "    буферов при использовании второго конструктора зависит от значения параметра\n" +
                        "    autoFlush. Если он равен true, автоматический сброс буферов выполняется,\n" +
                        "    а если false - нет.\n" +
                        " Набор реализаций основных методов print и println класса PrintWriter аналогичен\n" +
                        " набору реализация этих методов класса PrintStream.\n" +
                        " Здесь же мы упомянем только методы flush и checkError.\n" +
                        " Метод flush вызывает принудительный сброс буфера вывода. Если поток PrintWriter\n" +
                        " создан на базе стандартного потока вывода System.out, то записанные в него данные\n" +
                        " появятся на консоли только после выполнения сброса буфера (автоматического или\n" +
                        " сделанного методом flush).\n" +
                        " Что же касается метода checkError, то в случае возникновения ошибок он возвращает\n" +
                        " значение true."); //ответ 294
        answersList.add(" В отличие от большинства классов ввода/вывода, класс File работает не с потоками,\n" +
                        " а непосредственно с файлами. Данный класс позволяет получить информацию о файле:\n" +
                        " права доступа, время и дата создания, путь к каталогу. А также осуществлять\n" +
                        " навигацию по иерархиям подкаталогов.\n" +
                        " Класс java.io.File может представлять имя определённого файла, а также имена группы\n" +
                        " файлов, находящихся в каталоге. Если класс представляет каталог, то его метод list()\n" +
                        " возвращает массив строк с именами всех файлов. Для создания объектов класса File можно\n" +
                        " использовать один из следующих конструкторов:\n" +
                        " 1) File(File dir, String name) - указывается объекта класса File (каталог) и имя файла\n" +
                        " 2) File(String path) - указывается путь к файлу без указания имени файла\n" +
                        " 3) File(String dirPath, Sring name) - указывается путь к файлу и имя файла\n" +
                        " 4) File(URI url) - указывается объекта URI, описывающий файл\n"); //ответ 295
        answersList.add(" Для различных систем символ разделителя различается. Вытащить его можно используя\n" +
                        " file.separator, а так же в статическом поле File.separator. Для Windows это \"\\\"."); //ответ 296
        answersList.add(" У класса File очень много методов, перечислим некоторые:\n" +
                        " 1) getAbsolutePath() - абсолютный путь файла, начиная с корня системы.\n" +
                        "    В Android корневым элементом является символ слеша (/)\n" +
                        " 2) canRead() - доступно для чтения\n" +
                        " 3) canWrite() - доступно для записи\n" +
                        " 4) exists() - файл существует или нет\n" +
                        " 5) getName() - возвращает имя файла\n" +
                        " 6) getParent() - возвращает имя родительского каталога\n" +
                        " 7) getPath() - путь\n" +
                        " 8) lastModified() - дата последнего изменения\n" +
                        " 9) isFile() - объект является файлом, а не каталогом\n" +
                        "10) isDirectory - объект является каталогом\n" +
                        "11) isAbsolute() - возвращает true, если файл имеет абсолютный путь\n" +
                        "12) renameTo(File newPath) - переименовывает файл. В параметре указывается имя\n" +
                        "    нового имени файла. Если переименование прошло неудачно, то возвращается\n" +
                        "    false\n" +
                        "13) delete() - удаляет файл. Также можно удалить пустой каталог"); //ответ 297
        answersList.add(" Интерфейс FileFilter применяется для проверки, попадает ли объект ли объект\n" +
                        " File под некоторое условие. Этот интерфейс содержит единственный метод\n" +
                        " boolean accept(File pathName). Этот метод необходимо переопределить\n" +
                        " и реализовать."); //ответ 298
        answersList.add(" DeflaterOutputStream, InflaterInputStream, ZipInputStream, ZipOutputStream,\n" +
                        " GZIPInputStream, GZIPOutputStream."); //ответ 299

        //6) MULTITHREADING
        answersList.add(" Процесс это некоторая единица операционной системы, которой выделена память\n" +
                        " и другие ресурсы. Поток это единица исполнения кода. Поток имеет стэк - некоторую\n" +
                        " свою память для исполнения. Остальная память процесса - общая для всех его потоков.\n" +
                        " Потоки исполняются на ядрах процессора. В некоторых OS разница между процессами\n" +
                        " и потоками сведена к минимуму."); //ответ 300
        answersList.add(" Есть несколько способов создания и запуска потоков:\n" +
                        " 1) С помощью класса, реализующего Runnable:\n" +
                        "    1.1) Создать объект класса Thread.\n" +
                        "    1.2) Создать объект класса, реализующего интерфейс Runnable.\n" +
                        "    1.3) Вызвать у созданного объекта Thread метод start()\n" +
                        "         (после этого запустится метод run() у переданного объекта, реализующего\n" +
                        "          Runnable).\n" +
                        " 2) С помощью класса, расширяющего Thread:\n" +
                        "    2.1) Создать объект класса ClassName extends Thread.\n" +
                        "    2.2) Переопределить run() в этом классе (смотрите примере ниже,\n" +
                        "         где передается имя потока 'Second').\n" +
                        " 3) С помощью класса, реализующего java.util.concurrent.Callable:\n" +
                        "    3.1) Создать объект класса, реализующего интерфейс Callable.\n" +
                        "    3.2) Создать объект ExecutorService с указанием пула потоков.\n" +
                        "    3.3) Создать объект Future. Запуск происходит через метод submit();\n" +
                        "         Сигнатура: <T> Future<T> submit(Callable<T> task)."); //ответ 301
        answersList.add(" Контроль за доступом к объекту-ресурсу обеспечивает понятие монитора.\n" +
                        " Монитор экземпляра может иметь только одного владельца. При попытке\n" +
                        " конкурирующего доступа к объекту, чей монитор имеет владельца, желающий\n" +
                        " заблокировать объект-ресурс поток должен подождать освобождения монитора\n" +
                        " этого объекта и только после этого завладеть им и начать использование\n" +
                        " объекта-ресурса."); //ответ 302
        answersList.add(" Ниже приведены некоторые способы синхронизации в Java:\n" +
                        " 1) Системная синхронизация с использованием wait/notify. Поток, который\n" +
                        "    ждет выполнения каких-либо условий, вызывает у этого объекта метод wait,\n" +
                        "    предварительно захватив его монитор. На этом его работа приостанавливается.\n" +
                        "    Другой поток может вызвать на этом же самом объекте метод notify (опять же,\n" +
                        "    предварительно захватив монитор объекта), в результате чего, ждущий на объекте\n" +
                        "    поток \"просыпается\" и продолжает свое выполнение.\n" +
                        " 2) Системная синхронизация с использованием join.\n" +
                        "    Метод join, вызванный у экземпляра класса Thread, позволяет текущему потоку\n" +
                        "    остановиться до того момента, как поток, связаный с этим экземпляром, закончит\n" +
                        "    работу.\n" +
                        " 3) Использование классов из пакета java.util.concurrent, который предоставляет набор\n" +
                        "    классов для организации межпоточного взаимодействия. Примеры таких классов - Lock,\n" +
                        "    семафор (Semaphore), etc. Концепция данного подхода заключается в использовании\n" +
                        "    атомарных операций и переменных."); //ответ 303
        answersList.add(" Эти метеоды предназначены для межпоточной синхронизации, для взаимодействия потоков\n" +
                        " между собой. Как работают эти методы? Во-первых они могут вызваны только потоком,\n" +
                        " который захватил монитор объекта, для которого эти методы вызываются. То есть они\n" +
                        " вызываются внутри блока synchronized и для объекта, монитор которого этим synchronized\n" +
                        " захвачен. Если внутри synchronized метода - то для класса, к которому относятся эти\n" +
                        " методы. Что делает метод wait(). Метод wait() отдает (освобождает) монитор объекта,\n" +
                        " так что другие потоки теперь могут его (монитор) захватить, то есть войти в блок\n" +
                        " synchronized для этого объекта. Затем метод wait() переходит в состояние ожидания,\n" +
                        " до тех пор пока другой поток не вызывет метод notify() или notifyAll() для этого же\n" +
                        " объекта. После чего поток, в котором был вызван wait(), пытается снова захватить\n" +
                        " монитор объекта и когда монитор становится свободным, то есть когда другой поток\n" +
                        " освобождает его, захватывает монитор и продолжает выполнение со следующего после\n" +
                        " wait() оператора. Причем у потока вызвашего wait() нет никакого преимущества перед\n" +
                        " другими потоками, ожидающими захвата того же монитора. Что делают методы notify(),\n" +
                        " notifyAll()? Они \"пробуждают\" поток, ожидающий методом wait() (если такой есть),\n" +
                        " и переводят его в состояние ожидания освобождения монитора. Разница между notify()\n" +
                        " и notifyAll() в том, что notify() пробуждает только один поток, ожидающий методом\n" +
                        " wait(), какой именно будет пробужден - определить нельзя, а notifyAll() - все такие\n" +
                        " потоки."); //ответ 304
        answersList.add(" Разница методов в следующем:\n" +
                        " 1) final void wait() - метод используется в многопоточной среде, может вызываться только\n" +
                        "    потоком, владеющим объектом синхронизации. При этом объект синхронизации освобождается,\n" +
                        "    а текущий поток переходит в режим ожидания сигнала освобождения объекта синхронизации\n" +
                        "    другим потоком путем вызова метода notify() либо notifyAll().\n" +
                        " 2) final void wait(long time) &nbsp;- аналогично wait() данный метод используется\n" +
                        "    в многопоточной среде, переходит текущий поток в режим ожидания сигнала\n" +
                        "    освобождения объекта синхронизации другим потоком путем вызова метода notify()\n" +
                        "    либо notifyAll(), или ожидание происходит заданное время time, затем выполнение\n" +
                        "    продолжается безусловно."); //ответ 305
        answersList.add(" Основные отличия:\n" +
                        " 1) метод yield() - пытается сказать планировщику потоков, что нужно выполнить другой\n" +
                        "    поток, что ожидает в очереди на выполнение. Метод не пытается перевести текущий поток\n" +
                        "    в состояние блокировки, сна или ожидания. Он просто пытается его перевести из состояние\n" +
                        "    \"работающий\" в состояние \"работоспособный\". Однако выполнение метода может вообще\n" +
                        "    не произвести никакого эффекта - состояние потока остается RUNNABLE\n" +
                        " 2) метод sleep() - приостанавливает поток на указанное. состояние меняется на\n" +
                        "    TIMED_WAITING, по истечению - RUNNABLE\n" +
                        " 3) метод wait() - меняет состояние потока на WAITING. Может быть вызвано только\n" +
                        "    у объекта владеющего блокировкой, в противном случае выкинется исключение\n" +
                        "    IllegalMonitorStateException. при срабатывании метода блокировка отпускается,\n" +
                        "    что позволяет продолжить работу другим потокам ожидающим захватить ту же самую\n" +
                        "    блокировку . в случае wait(int) с аргументом состояние будет TIMED_WAITING."); //ответ 306
        answersList.add(" Метод join() вызывается для того, чтобы привязать текущий поток в конец потока\n" +
                        " для которого вызывается метод. То есть второй поток будет в режиме блокировки\n" +
                        " пока первый поток не выполнится."); //ответ 307
        answersList.add(" Это когда один поток А получил блокировку на объект А1, а поток В получил блокировку\n" +
                        " на объект В1. В то время как поток А пытается получит блокировку на объект В1,\n" +
                        " а поток В на А1."); //ответ 308
        answersList.add(" Представьте себе ситуацию что два потока одновременно изменяют состояние какого-то\n" +
                        " объекта, это недопустимо. Для этого необходимо синхронизировать потоки. Как это\n" +
                        " сделать? Ключевое слово synchronized позволяет это сделать установив в сигнатуре\n" +
                        " метода. Или же в методе можно описать блок synchronized, только в качестве параметра\n" +
                        " необходимо передать объект, который будет блокироватся.\n" +
                        " Представьте себе ситуацию когда один поток ждет пока разблокируется объект... а если\n" +
                        " это ждут несколько потоков? Нет гарантии что тот объект что больше всех ждал снятия\n" +
                        " блокировки будет выполнятся первым.\n" +
                        " Статические синхронизированные методы и нестатические синхронизированные методы\n" +
                        " не будет блокировать друг друга, никогда. Статические методы блокируются\n" +
                        " на экземпляре класса Class в то время как нестатические методы блокируются на текущем\n" +
                        " экземпляре (this). Эти действия не мешают друг другу.\n" +
                        " wait() - отказывается от блокировки остальные методы сохраняют блокировку."); //ответ 309
        answersList.add(" Краткое описание ключевых слов:\n" +
                        " 1) volatile - указывает на то, что поле синхронизировано для нескольких потоков\n" +
                        " 2) synchronized - указывает на то что метод синхронизированный или же в методе\n" +
                        "    может находится такой блок синхронизации.\n" +
                        " 3) transient - указывает на то, что переменная не подлежит сериализации\n" +
                        " 4) native - говорит о том, что реализация метода написана на другой программной\n" +
                        "    платформе"); //ответ 310
        answersList.add(" Приоритет потока - это число от 1 до 10, в &nbsp;зависимости от которого,\n" +
                        " планировщик потоков выбирает какой поток запускать. Однако полагаться\n" +
                        " на приоритеты для предсказуемого выполнения многопоточной программы нельзя!"); //ответ 311
        answersList.add(" Это потоки, которое работают в фоновом &nbsp;режиме и не гарантируют что они\n" +
                        " завершатся. Тоеть если все потоки завершились, то поток демон просто обрывается\n" +
                        " вместе с закрытием приложения."); //ответ 312
        answersList.add(" Перевести поток в спящее состояние можно с помощью метода sleep(long ms)\n" +
                        " ms - время в миллисекундах. При вызове этого метода, поток переходит\n" +
                        " в спящее состояние, после сна, поток переходит в пул потоков и находится\n" +
                        " в состоянии \"работоспособный\", т.е. не гарантируется что после пробуждения\n" +
                        " он будет сразу выполняться. Также поток не может усыпить другой поток,\n" +
                        " так как метод sleep - это статический метод! Вы просто усыпите текущий\n" +
                        " поток и не более того! Также метод sleep() может возбуждать\n" +
                        " InterruptedException()."); //ответ 313
        answersList.add(" У нас есть текущий поток, в котором выполняется метод main.\n" +
                        " Этот поток имеет свой стек и этот стек начинается с вызова метода main.\n" +
                        " Далее в методе main мы создаем новый поток, что происходит? создается\n" +
                        " новый поток и для него выделяется свой стек с первоначальным методом run().\n" +
                        " Когда мы запускаем несколько потоков, то мы не можем гарантировать определенный\n" +
                        " порядок их вызовов. Планированием потоков занимается планировщик потоков JVM,\n" +
                        " выбирая из пулов потоков поток. Мы даже не можем гарантировать что если первый\n" +
                        " поток начался &nbsp;выполнятся первым, то он и закончит выполнятся первым,\n" +
                        " он может закончить выполнятся последним. Еще такой ньюанс, что поток, который\n" +
                        " закончил свое выполнение, не может быть повторно запущен! Он находится\n" +
                        " в состоянии \"мертвый\", а для запуска потока нового потока, объект должен\n" +
                        " находится в состоянии \"новый\".\n" +
                        " Потоки имеют такие состояния:\n" +
                        " 1) новый(это когда только создали экземпляр класса Thread)\n" +
                        " 2) живой &nbsp;или работоспособный(переходит в это состояние после запуска\n" +
                        "    метода start(), но это не означает что поток уже работает! Или же он может\n" +
                        "    перейти в это состояние из состояние работающий или блокированный)\n" +
                        " 3) работающий(это когда метод run() начал выполнятся)\n" +
                        " 4) ожидающий (waiting)/Заблокированный (blocked)/Спящий(sleeping).\n" +
                        "    Эти состояния характеризуют поток как не готовый к работе. Я объединил эти\n" +
                        "    состояния т.к. все они имеют общую черту - поток еще жив (alive),\n" +
                        "    но в настоящее время не может быть выполнен. Другими словами поток уже\n" +
                        "    не работает, но он может вернутся в рабочее состояние.\n" +
                        "    Поток может быть заблокирован, это может означать что он ждет освобождение\n" +
                        "    каких-то ресурсов. Поток может спать, если встретился метод sleep(long s),\n" +
                        "    или же он может ожидать, если встретился метод wait(), он будет ждать пока\n" +
                        "    не вызовится метод notify() или notifyall().\n" +
                        " 5) мертвый(состояние когда метод run() завершил свою работу)"); //ответ 314
        answersList.add(" Основные различия:\n" +
                        " 1) Интерфейс Runnable появиля в Java 1.0, а интерфейс Callable был введен\n" +
                        "    в Java 5.0 в составе библиотеки java.util.concurrent.\n" +
                        " 2) Классы, реализующие интерфейс Runnable должны реализовывать метод run()\n" +
                        "    для выполнения задачи. Классы, реализующие интерфейс Callable должны\n" +
                        "    реализовывать метод call() для выполнения задачи.\n" +
                        " 3) Метод Runnable.run() не возвращает никакого значения, его тип void,\n" +
                        "    а метод Callable.call() может возвращать значение типа T. Интерфейс\n" +
                        "    Callable является параметризированным Callable<T> и тип значения,\n" +
                        "    которое будет возвращаться в методе call() задается этим параметром T.\n" +
                        " 4) Метод run() не может бросить проверяемое исключение, в то время как метод\n" +
                        "    call() может бросить проверяемое исключение."); //ответ 315
        answersList.add(" Хоть оба эти синхронизаторы позволяют нитям дожидаться друг друга, главное\n" +
                        " различие между ними в том, что вы не можете заново использовать CountDownLatch\n" +
                        " после того, как его счётчик достигнет нуля, но вы можете использовать\n" +
                        " CyclicBarrier снова, даже после того, как барьер сломается."); //ответ 316
        answersList.add(" Состояние гонки - причина трудноуловимых багов. Как сказано в самом названии,\n" +
                        " состояние гонки возникает из-за гонки между несколькими нитями, если нить,\n" +
                        " которая должна исполнятся первой, проиграла гонку и исполняется вторая,\n" +
                        " поведение кода изменяется, из-за чего возникают недетерменированные баги.\n" +
                        " Это одни из сложнейших к отлавливанию и воспроизведению багов, из-за\n" +
                        " беспорядочной природы гонок между нитями. Пример состояния гонки - беспорядочное\n" +
                        " исполнение."); //ответ 317
        answersList.add(" Java предоставляет богатые API для всего, но, по иронии судьбы, не предоставляет\n" +
                        " удобных способов остановки нити. В JDK 1.0 было несколько управляющих методов,\n" +
                        " например stop(), suspend() и resume(), которые были помечены как deprecated\n" +
                        " в будущих релизах из-за потенциальных угроз взаимной блокировки, с тех пор\n" +
                        " разработчики Java API не предприняли попыток представить стойкий, ните-безопасный\n" +
                        " и элегантный способ остановки нитей. Программисты в основном полагаются на\n" +
                        " факт того, что нить останавливается сама, как только заканчивает выполнять\n" +
                        " методы run() или call(). Для остановки вручную, программисты пользуются\n" +
                        " преимуществом volatile boolean переменной и проверяют её значение в каждой\n" +
                        " итерации, если в методе run() есть циклы, или прерывают нити методом interrupt()\n" +
                        " для внезапной отмены заданий."); //ответ 318
        answersList.add(" Это один из хороших вопросов с подвохом. Простыми словами, если исключение\n" +
                        " не поймано - нить мерта, если установлен обработчик непойманных исключений,\n" +
                        " он получит колбек.\n" +
                        " Thread.UncaughtExceptionHandler - интерфейс, определённый как вложенный\n" +
                        " интерфейс для обработчиков, вызываемых, когда нить внезапно останавливается\n" +
                        " из-за непойманного исключения. Когда нить собирается остановится из-за\n" +
                        " непойманного исключения, JVM проверит её на наличие UncaughtExceptionHandler,\n" +
                        " используя Thread.getUncaughtExceptionHandler(), и вызовет у обработчика метод\n" +
                        " uncaughtException(), передав нить и исключение в виде аргументов."); //ответ 319
        answersList.add(" ThreadLocal переменные - специальный вид переменных, доступных Java программисту.\n" +
                        " Так же, как для состояний есть переменная состояния, для нитей есть ThreadLocal\n" +
                        " переменные. Это неплохой способ достичь ните-безопасности для затратных-для-создания\n" +
                        " объектов, например вы можете сделать SimpleDateFormat ните-безопасным, используя\n" +
                        " ThreadLocal. Так как это затратный класс, его нежелательно использовать в локальной\n" +
                        " области, которая требует отдельных экземпляров на каждый вызов. Предоставляя каждой\n" +
                        " нити её собственную копию, вы убиваете двух зайцев. Во-первых, вы уменьшаете\n" +
                        " количество экземпляров затратных объектов, используя по новой фиксированное количество\n" +
                        " экземпляров, и во-вторых, вы достигаете ните-безопасности, без потерь синхронизации\n" +
                        " и неизменяемости. Ещё один хороший пример локальной переменной у нити - класс\n" +
                        " ThreadLocalRandom, который уменьшает количество экземпляров затратных-для-создания\n" +
                        " объектов Random в много-нитиевой среде."); //ответ 320
        answersList.add(" FutureTask представляет собой отменяемое асинхронное вычисление в параллельном Java\n" +
                        " приложении. Этот класс предоставляет базовую реализацию Future, с методами для запуска\n" +
                        " и остановки вычисления, методами для запроса состояния вычисления и извлечения\n" +
                        " результатов. Результат может быть получен только когда вычисление завершено, метод\n" +
                        " получения будет заблокирован, если вычисление ещё не завершено.\n" +
                        " Объекты FutureTask могут быть использованы для обёртки объектов Callable и Runnable.\n" +
                        " Так как FutureTask реализует Runnable, его можно передать \"Executor\"-у на выполнение.\n"); //ответ 321
        answersList.add(" Основное различие между interrupted() и isInterrupted() в том, что первый сбрасывает\n" +
                        " статус прерывания, а второй нет. Механизм прерывания в Java реализован с использованием\n" +
                        " внутреннего флага, известного как статус прерывания. Прерывание нити вызовом\n" +
                        " Thread.interrupt() устанавливает этот флаг. Когда прерванная нить проверяет статус\n" +
                        " прерывания, вызывая статический метод Thread.interrupted(), статус прерывания\n" +
                        " сбрасывается. Нестатический метод isInterrupted(), который используется нитью для\n" +
                        " проверки статуса прерывания у другой нити, не изменяет флаг прерывания.\n" +
                        " Условно, любой метод, который завершается, выкинув InterruptedException сбрасывает\n" +
                        " при этом флаг прерывания. Однако, всегда существует возможность того, что флаг тут же\n" +
                        " снова установится, если другая нить вызовет interrupt()."); //ответ 322
        answersList.add(" Основная причина вызова wait и notify из синхронизированого блока или метода в том,\n" +
                        " что Java API обязательно требует этого. Если вы вызовете их не из синхронизированного\n" +
                        " блока, ваш код выбросит IllegalMonitorStateException. Более хитрая причина в том,\n" +
                        " чтобы избежать состояния гонки между вызовами wait и notify."); //ответ 323
        answersList.add(" Создание нити затратно в плане времени и ресурсов. Если вы создаёте нить во время\n" +
                        " обработки запроса, это замедлит время отклика, также процесс может создать только\n" +
                        " ограниченное число нитей. Чтобы избежать этих проблем, во время запуска приложения\n" +
                        " создаётся пул нитей и нити повторно используются для обработки запросов.\n" +
                        " Этот пул нитей называется \"thread pool\", а нити в нём - рабочая нить.\n" +
                        " Начиная с Java 1.5 Java API предоставляет фреймворк Executor, который позволяет вам\n" +
                        " создавать различные пулы нитей, например single thread pool, который обрабатывает\n" +
                        " только одно задание за единицу времени, fixed thread pool, пул с фиксированным\n" +
                        " количеством нитей, и cached thread pool, расширяемый пул, подходящий для приложений\n" +
                        " с множеством недолгих заданий."); //ответ 324
        answersList.add(" Livelock схож с deadlock, только в livelock состояния нитей или вовлечённых процессов\n" +
                        " постоянно изменяются в зависимости друг от друга. Livelock - особый случай нехватки\n" +
                        " ресурсов. Реальный пример livelock'а - когда два человека встречаются в узком коридоре\n" +
                        " и каждый, пытаясь быть вежливым, отходит в сторону, и так они бесконечно двигаются из\n" +
                        " стороны в сторону."); //ответ 325
        answersList.add(" Я и не подозревал, что можно проверять, удерживает ли нить lock в данный момент,\n" +
                        " до тех пор, пока не столкнулся с этим вопросом в одном телефонном интервью.\n" +
                        " В java.lang.Thread есть метод holdsLock(), он возвращает true, тогда и только\n" +
                        " тогда, когда текущая нить удерживает монитор у определённого объекта."); //ответ 326
        answersList.add(" Дамп нити позволяет узнать, чем нить занимается в данный момент.\n" +
                        " Существует несколько способов получения дампа нити, зависящих от операционной\n" +
                        " системы. В Windows вы можете использовать комбинацию ctrl + Break, в Linux - команду\n" +
                        " kill -3. Также вы можете воспользоваться утилитой jstack, она оперирует над id процесса,\n" +
                        " который вы можете узнать с помощью другой утилиты jps."); //ответ 327
        answersList.add(" Это один из простых, -Xss параметер используется для контроля размера стека нити в Java."); //ответ 328
        answersList.add(" Были времена, когда единственный способ достижения взаимного исключения был через\n" +
                        " ключевое слово synchronized, но он имеет несколько недостатков, например нельзя\n" +
                        " расширить lock за пределами метода или блока кода и т.д. Java 5 решает эту проблему,\n" +
                        " предоставляя более утончённый контроль через интерфейс Lock.\n" +
                        " ReentrantLock - распространённая реализация Lock, которая предоставляет Lock с таким же\n" +
                        " базовым поведением и семантикой, как у неявного монитора, достигаемый использованием\n" +
                        " синхронизированных методов, но с расширенными возможностями."); //ответ 329
        answersList.add(" Semaphore - это новый тип синхронизатора. Это семафор со счётчиком.\n" +
                        " Концептуально, семафор управляет набором разрешений. Каждый acquire()\n" +
                        " блокируется, если необходимо, до того, как разрешение доступно, затем получает\n" +
                        " его. Каждый release() добавляет разрешение, потенциально освобождая блокирующий\n" +
                        " получатель (acquirer). Однако при этом не используются фактические объекты\n" +
                        " разрешений; Semaphore просто хранит количество доступных и действует соответственно.\n" +
                        " Semaphore используется для защиты дорогих ресурсов, которые доступны в ограниченном\n" +
                        " количестве, например подключение к базе данных в пуле."); //ответ 330
        answersList.add(" Если очередь пула нитей заполнилась, то поданная задача будет \"отклонена\".\n" +
                        " Метод submit() у ThreadPoolExecutor'а выкидывает RejectedExecutionException,\n" +
                        " после чего вызывается RejectedExecutionHandler."); //ответ 331
        answersList.add(" Оба метода являются способами подачи задачи в пул нитей, но между ними есть\n" +
                        " небольшая разница. Execute(Runnable command) определён в интерфейсе Executor\n" +
                        " и выполняет поданную задачу в будущем, но, что более важно, ничего\n" +
                        " не возвращает. С другой стороны submit() - перегруженный метод, который может\n" +
                        " принимать задачи типов Runnable и Callable и может возвращать объект Future,\n" +
                        " который можно использовать для отмены выполнения и/или ожидания результата\n" +
                        " вычислений. Этот метод определён в интерфейсе ExecutorService, который\n" +
                        " наследуется от интерфейса Executor, и каждый класс пула нитей, например\n" +
                        " ThreadPoolExecutor или ScheduledThreadPoolExecutor, наследует эти методы."); //ответ 332
        answersList.add(" Блокирующий метод - метод, который блокируется, до тех пор, пока\n" +
                        " не выполнится задание, например метод accept() у ServerSocket блокируется\n" +
                        " в ожидании подключения клиента. Здесь блокирование означает, что контроль\n" +
                        " не вернётся к вызывающему методу до тех пор, пока не выполнится задание.\n" +
                        " С другой стороны, существуют асинхронные или не блокирующиеся методы, которые\n" +
                        " завершаются до выполнения задачи."); //ответ 333
        answersList.add(" В целом, ReadWriteLock - это результат техники разбора \"lock\"-а для улучшения\n" +
                        " производительности параллельных приложений. Это интерфейс, который был добавлен\n" +
                        " в Java 5. Он оперирует парой связанных \"lock\"-ов, один для операций чтения,\n" +
                        " один для записи. Читающий lock может удерживаться одновременно несколькими\n" +
                        " читающими нитями, до тех пор пока не будет записывающих. Записывающий lock\n" +
                        " эксклюзивен. Если хотите, вы можете реализовать интерфейс с вашим набором правил,\n" +
                        " или вы можете использовать ReentrantReadWriteLock, который поддерживает максимум\n" +
                        " 65535 рекурсивных записывающих lock'ов и 65535 читающих \"lock\"-ов."); //ответ 334
        answersList.add(" Это старый способ создания ните-безопасного синглтона, который пытается\n" +
                        " оптимизировать производительность, блокируясь только когда экземпляр синглтона\n" +
                        " создаётся впервые."); //ответ 335
        answersList.add(" Фреймворк Fork/Join, представленный в JDK 7, - это мощная утилита, позволяющая\n" +
                        " разработчику пользоваться преимуществами нескольких процессоров у современных\n" +
                        " серверов. Он разработан для работы, которую можно рекурсивно разбить на маленькие\n" +
                        " частицы. Цель - использовать всю доступную вычислительную мощь, для увеличения\n" +
                        " производительности вашего приложения. Одного значительное преимущество этого\n" +
                        " фреймворка в том, что он использует work-stealing алгоритм\n" +
                        " (от work - работа и steal - красть). Рабочие нити, у которых закончились свои задания,\n" +
                        " могут \"своровать\" задания у других нитей, которые всё ещё заняты."); //ответ 336

    }
}
